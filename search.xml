<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>蚁群算法</title>
      <link href="/2023/03/22/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/22/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="蚁群优化算法"><a href="#蚁群优化算法" class="headerlink" title="蚁群优化算法"></a>蚁群优化算法</h3><p><strong>1. 仿生物学原理</strong></p><p>蚂蚁在寻找食物源时，会在其经过的路径上释放一种信息素，并能够感知其它蚂蚁释放的信息素。信息素浓度的大小表征到食物源路径的远近，信息素浓度越高，表示对应的路径距离越短。通常，蚂蚁会以较大的概率优先选择信息素浓度较高的路径，并释放一定量的信息素，以增强该条路径上的信息素浓度，这样会形成一个正反馈。最终，蚂蚁能够找到一条从巢穴到食物源的最佳路径，即最短距离。值得一提的是，生物学家同时发现，路径上的信息素浓度会随着时间的推进而逐渐衰减。</p><p><strong>启发：</strong> 用蚂蚁的行走路径表示待优化问题的可行解，整个蚂蚁群体的所有路径构成待优化问题的解空间。路径较短的蚂蚁释放的信息素量较多，随着时间的推进，较短的路径上积累的信息素浓度逐渐增高，选择该路径上的蚂蚁个数也越来越多。最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。</p><ul><li><p>蚁群算法的优势</p><p>（1）易获得全局最优解；</p><p>（2）应用面广，易与其他问题结合；</p><p>（3）分布式计算方式，多个个体并行运算，大大提升算法的运行效率；</p><p>（4）鲁棒性强，采用正反馈机制，使得搜索过程不断收敛，逼近最优解，通常应用于图论算法；</p></li><li><p>蚁群算法劣势</p></li></ul><p>​（1）虽然一定会收敛，但无法确定收敛所需的时间；</p><p>​（2）理论分析较为困难，算法更侧重于实践层面；</p><p><strong>2. 蚁群算法解决TSP问题</strong></p><ul><li>算法原理：</li></ul><p>​蚂蚁群体数量为 $m$ , 城市数量 $n$, 城市 $i$ 和城市 $j$ 之间的距离为 $d_{ij}$，$t$ 时刻城市 $i$ 与 城市 $j$ 路上的信息素浓度为 $\tau_{ij}(t)$。初始时刻，各个城市间连接路径上的信息素浓度相同，不妨设 $\tau_{ij}(0) = \tau_{0}$ 。</p><p>蚂蚁 $k,(k=1,2,…m)$ 根据各个城市间连接路径上的信息素浓度决定下一个访问城市，设 $P_{ij}^{k}(t)$ 表示 $t$ 时刻蚂蚁 $k$ 从城市 $i$ 转移到 城市 $j$ 的转移概率，其公式为：</p><p><img src="/images/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/image-20230322233242999.png" alt="结点转移公式"></p><p>其中 $\eta_{ij}(t) = \frac{1}{d_{ij}}$ 为启发式函数，表示蚂蚁从城市 $i$ 转移到城市 $j$ 的期望程度，路径越长越不期望走这条路；$allow_{k}$ 为蚂蚁 $k$ 待访问城市的集合；<u>$\alpha$ 为信息素重要程度因子，其值越大，表示信息素的浓度在转移过程中起的作用越大；$\beta$ 为启发式函数重要程度因子，其值越大，表示启发式函数在转移过程中作用越大，即蚂蚁会以较大的概率转移到距离短的城市。</u>如果 $\alpha$ 为 0，那么蚂蚁转移不依据信息素，即群体经验，算法就转变为贪心算法。如果 $\beta = 0$，那就不会依据距离来转移，完全根据群体的经验。经过 $n$ 个时刻，所有蚂蚁走完了所有的城市，完成了一次循环，每只蚂蚁所走过的路径就是一个解。</p><p><u>由于蚂蚁释放信息素的同时，各个城市间路径上的信息素会逐渐消失，设参数 $\rho (0 &lt; \rho &lt; 1)$ 表示信息素的挥发程度。</u>因此，当所有蚂蚁完成一次循环后，各个城市间信息素浓度需要进行实时更新，即：</p><p><img src="/images/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/image-20230322233312758.png" alt="信息素更新公式"></p><p> $\bigtriangleup\tau_{ij}^{k}$ 表示第 $k$ 只蚂蚁在城市 $i$ 与 城市 $j$ 连接路径上释放的信息素浓度；$\bigtriangleup\tau_{ij}$ 表示所有蚂蚁在城市 $i$ 和城市 $j$ 连接路径上释放的信息素浓度之和。</p><p>蚂蚁释放信息素的模型：</p><p>（1）Ant Cycle System模型</p><p>​$\bigtriangleup\tau_{ij}^{k} = \frac{Q}{L_{k}}$，第 $k$ 只蚂蚁从城市 $i$ 访问城市 $j$ , 其中 $Q$ 表示一只蚂蚁一个循环所能产生的信息素总量；$L_{k}$ 为第 $k$ 只蚂蚁经过路径的长度。</p><p>（2）Ant Quantity System</p><p>​$\bigtriangleup\tau_{ij}^{k} = \frac{Q}{d_{ij}}$ , 第 $k$ 只蚂蚁从城市 $i$ 访问城市 $j$</p><p>（3）Ant Density System</p><p>​$\bigtriangleup\tau_{ij}^{k} = Q$</p><p>​一般选用 Ant Cycle System 模型来计算释放信息素的浓度，蚂蚁经过的路径越短，释放信息素的浓度越高。</p><ul><li><p>算法步骤</p><p>（1）初始化参数</p><p>​需要对相关参数进行初始化，入蚁群规模（蚂蚁数量）m、信息素重要程度因子 $\alpha$ 、启发函数重要程度因子 $\beta$ 、信息素挥发程度因子 $\rho$ 、信息素释放总量 $Q$、最大迭代次数 $iter_{max}$ 。</p><p>​同时，需要计算一个距离矩阵，即两两城市之间的相互距离，从而得到对称的距离。由于启发函数为 $\eta_{ij}(t) = \frac{1}{d_{ij}}$ ，为了保证分母不为 0 , 需要将对角线上的元素修正为一个比较小的正数（$10^{-4}或10^{-5}$）</p><p>（2）构建解空间</p><p>​将各个蚂蚁随机的放置于不同的出发点，对每个蚂蚁 $k$ ，按照转移概率的计算公式，确定其下一个待访问的城市（轮盘赌法选择下一步的城市），直到所有蚂蚁访问完所有城市，即构造完一组路径。</p><p>（3）更新信息素</p><p>​计算各个蚂蚁经过的路径长度 $L_{k}$ , 根据信息素迭代公式对各个城市路径上的信息素浓度进行更新。同时，记录当前迭代次数中的最优解（最短路径）。</p><p>（4）判断是否终止，若达到最大的迭代次数则终止计算，输出最优解，否则，清空蚂蚁经过路径的记录表，并返回步骤 2。</p><p><img src="/images/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/image-20230322144352550.png" alt="蚁群算法流程图"></p></li><li><p>蚁群算法解TSP问题python代码</p><p>aco.py </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -- coding: utf-8 --</span><span class="token keyword">import</span> random<span class="token keyword">class</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    用来存储整个图中所有城市之间的距离以及信息素    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cost_matrix<span class="token punctuation">,</span> rank<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>matrix <span class="token operator">=</span> cost_matrix        self<span class="token punctuation">.</span>rank <span class="token operator">=</span> rank        self<span class="token punctuation">.</span>pheromone <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span>rank <span class="token operator">*</span> rank<span class="token punctuation">)</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">]</span>     <span class="token comment" spellcheck="true"># 初始化信息素为 1/(num_city * num_city)</span><span class="token keyword">class</span> <span class="token class-name">ACO</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ant_count<span class="token punctuation">,</span> generations<span class="token punctuation">,</span> alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> rho<span class="token punctuation">,</span> q<span class="token punctuation">,</span> strategy<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param ant_count: 蚁群数量        :param generations: 迭代次数        :param alpha: 信息素的重要程度        :param beta:  启发式信息重要程度        :param rho:   信息素挥发率        :param q:     一个个体一次循环所拥有的信息素的量        :param strategy:   信息素更新策略        """</span>        self<span class="token punctuation">.</span>Q <span class="token operator">=</span> q        self<span class="token punctuation">.</span>rho <span class="token operator">=</span> rho        self<span class="token punctuation">.</span>beta <span class="token operator">=</span> beta        self<span class="token punctuation">.</span>alpha <span class="token operator">=</span> alpha        self<span class="token punctuation">.</span>ant_count <span class="token operator">=</span> ant_count        self<span class="token punctuation">.</span>generations <span class="token operator">=</span> generations        self<span class="token punctuation">.</span>update_strategy <span class="token operator">=</span> strategy    <span class="token comment" spellcheck="true"># 更新信息素</span>    <span class="token keyword">def</span> <span class="token function">_update_pheromone</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> ants<span class="token punctuation">)</span><span class="token punctuation">:</span>               <span class="token comment" spellcheck="true"># ants 是所有蚂蚁所表示的解，即走过的路径</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> row <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>graph<span class="token punctuation">.</span>pheromone<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j<span class="token punctuation">,</span> col <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>graph<span class="token punctuation">.</span>pheromone<span class="token punctuation">)</span><span class="token punctuation">:</span>                graph<span class="token punctuation">.</span>pheromone<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*=</span> self<span class="token punctuation">.</span>rho           <span class="token comment" spellcheck="true"># 首先，当前已有的信息素是会挥发的</span>                <span class="token keyword">for</span> ant <span class="token keyword">in</span> ants<span class="token punctuation">:</span>                    graph<span class="token punctuation">.</span>pheromone<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> ant<span class="token punctuation">.</span>pheromone_delta<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>      <span class="token comment" spellcheck="true"># 其次要加上这些蚂蚁走过 i-j 这条边时留下的信息素，这个蚂蚁没有走过的边信息素为 0</span>    <span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 记录蚁群中最好的解</span>        best_cost <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>        best_solution <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> gen <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>generations<span class="token punctuation">)</span><span class="token punctuation">:</span>            ants <span class="token operator">=</span> <span class="token punctuation">[</span>_Ant<span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ant_count<span class="token punctuation">)</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># 这里的 self 是把 ACO 这个类传进 _Ant 类的 __init__() 方法</span>            <span class="token keyword">for</span> ant <span class="token keyword">in</span> ants<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 对每个蚂蚁都要进行 rank - 1 次选择下一次的结点</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>graph<span class="token punctuation">.</span>rank <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    ant<span class="token punctuation">.</span>_select_next<span class="token punctuation">(</span><span class="token punctuation">)</span>                ant<span class="token punctuation">.</span>total_cost <span class="token operator">+=</span> graph<span class="token punctuation">.</span>matrix<span class="token punctuation">[</span>ant<span class="token punctuation">.</span>tabu<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>ant<span class="token punctuation">.</span>tabu<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># 更新最优解</span>                <span class="token keyword">if</span> ant<span class="token punctuation">.</span>total_cost <span class="token operator">&lt;</span> best_cost<span class="token punctuation">:</span>                    best_cost <span class="token operator">=</span> ant<span class="token punctuation">.</span>total_cost                    best_solution <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">+</span> ant<span class="token punctuation">.</span>tabu                ant<span class="token punctuation">.</span>_update_pheromone_delta<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 每个蚂蚁产生新的信息素</span>            <span class="token comment" spellcheck="true"># 更新图中整体的信息素</span>            self<span class="token punctuation">.</span>_update_pheromone<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> ants<span class="token punctuation">)</span>        <span class="token keyword">return</span> best_solution<span class="token punctuation">,</span> best_cost<span class="token keyword">class</span> <span class="token class-name">_Ant</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> aco<span class="token punctuation">:</span>ACO<span class="token punctuation">,</span> graph<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>colony <span class="token operator">=</span> aco        self<span class="token punctuation">.</span>graph <span class="token operator">=</span> graph        <span class="token comment" spellcheck="true"># 记录解的结果</span>        self<span class="token punctuation">.</span>total_cost <span class="token operator">=</span> <span class="token number">0.0</span>        self<span class="token punctuation">.</span>tabu <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>               <span class="token comment" spellcheck="true"># tabu_list, 可以用来记录所走的边</span>        self<span class="token punctuation">.</span>pheromone_delta <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 该蚂蚁在每条边上产生的信息素的量</span>        self<span class="token punctuation">.</span>allowed <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>graph<span class="token punctuation">.</span>rank<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>eta <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">if</span> i<span class="token operator">==</span>j <span class="token keyword">else</span> <span class="token number">1</span><span class="token operator">/</span>graph<span class="token punctuation">.</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>graph<span class="token punctuation">.</span>rank<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>graph<span class="token punctuation">.</span>rank<span class="token punctuation">)</span><span class="token punctuation">]</span>     <span class="token comment" spellcheck="true"># 启发式信息</span>        start <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> graph<span class="token punctuation">.</span>rank<span class="token number">-1</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 开始从任意一个城市</span>        self<span class="token punctuation">.</span>tabu<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 这个点被访问过了就不会被访问了</span>        self<span class="token punctuation">.</span>current <span class="token operator">=</span> start        self<span class="token punctuation">.</span>allowed<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>start<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># allow 集合</span>    <span class="token keyword">def</span> <span class="token function">_select_next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        denominator <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 先计算分母</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> self<span class="token punctuation">.</span>allowed<span class="token punctuation">:</span>            denominator <span class="token operator">+=</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>pheromone<span class="token punctuation">[</span>self<span class="token punctuation">.</span>current<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">**</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>alpha <span class="token operator">*</span> self<span class="token punctuation">.</span>eta<span class="token punctuation">[</span>self<span class="token punctuation">.</span>current<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">**</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>beta        <span class="token comment" spellcheck="true"># 转移概率</span>        probabilities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>rank<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>allowed<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            probabilities<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>pheromone<span class="token punctuation">[</span>self<span class="token punctuation">.</span>current<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">**</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>alpha <span class="token operator">*</span> \                self<span class="token punctuation">.</span>eta<span class="token punctuation">[</span>self<span class="token punctuation">.</span>current<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">**</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>beta <span class="token operator">/</span> denominator        <span class="token comment" spellcheck="true"># 通过轮盘赌法来选择下一步选择的结点</span>        selected <span class="token operator">=</span> <span class="token number">0</span>        rand <span class="token operator">=</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> probabilities <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>probabilities<span class="token punctuation">)</span><span class="token punctuation">:</span>            rand <span class="token operator">-=</span> probabilities            <span class="token keyword">if</span> rand <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>                selected <span class="token operator">=</span> i                <span class="token keyword">break</span>        self<span class="token punctuation">.</span>allowed<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>selected<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tabu<span class="token punctuation">.</span>append<span class="token punctuation">(</span>selected<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>total_cost <span class="token operator">+=</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>matrix<span class="token punctuation">[</span>self<span class="token punctuation">.</span>current<span class="token punctuation">]</span><span class="token punctuation">[</span>selected<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>current <span class="token operator">=</span> selected    <span class="token comment" spellcheck="true"># 计算这个蚂蚁释放的信息素的浓度</span>    <span class="token keyword">def</span> <span class="token function">_update_pheromone_delta</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>pheromone_delta <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>rank<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>rank<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tabu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            i <span class="token operator">=</span> self<span class="token punctuation">.</span>tabu<span class="token punctuation">[</span>_ <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>            j <span class="token operator">=</span> self<span class="token punctuation">.</span>tabu<span class="token punctuation">[</span>_<span class="token punctuation">]</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>update_strategy <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># ant-density system</span>                self<span class="token punctuation">.</span>pheromone_delta<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>Q            <span class="token keyword">elif</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>update_strategy <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># ant-quantity system</span>                self<span class="token punctuation">.</span>pheromone_delta<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>Q <span class="token operator">/</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">.</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>pheromone_delta<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>colony<span class="token punctuation">.</span>Q <span class="token operator">/</span> self<span class="token punctuation">.</span>total_cost<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.py</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -- coding: utf-8 --</span><span class="token keyword">import</span> math<span class="token keyword">from</span> aco <span class="token keyword">import</span> ACO<span class="token punctuation">,</span> Graph<span class="token keyword">from</span> plot <span class="token keyword">import</span> plot<span class="token keyword">def</span> <span class="token function">distance</span><span class="token punctuation">(</span>city1<span class="token punctuation">,</span> city2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token punctuation">(</span>city1<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">-</span> city2<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>city1<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span> <span class="token operator">-</span> city2<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    cities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'./data/chn31.txt'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            city <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>            cities<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dict<span class="token punctuation">(</span>index<span class="token operator">=</span>int<span class="token punctuation">(</span>city<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token operator">=</span>int<span class="token punctuation">(</span>city<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token operator">=</span>int<span class="token punctuation">(</span>city<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 存放城市字典</span>            points<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>city<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>city<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                 <span class="token comment" spellcheck="true"># 城市位置</span>    cost_matrix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    rank <span class="token operator">=</span> len<span class="token punctuation">(</span>cities<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">:</span>        row <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">:</span>            row<span class="token punctuation">.</span>append<span class="token punctuation">(</span>distance<span class="token punctuation">(</span>cities<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> cities<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        cost_matrix<span class="token punctuation">.</span>append<span class="token punctuation">(</span>row<span class="token punctuation">)</span>    aco <span class="token operator">=</span> ACO<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">10.0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    graph <span class="token operator">=</span> Graph<span class="token punctuation">(</span>cost_matrix<span class="token punctuation">,</span> rank<span class="token punctuation">)</span>    path<span class="token punctuation">,</span> cost <span class="token operator">=</span> aco<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>graph<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cost:{}, path:{}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>cost<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span>    plot<span class="token punctuation">(</span>points<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>plot.py</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -- coding: utf-8 --</span><span class="token keyword">import</span> operator<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">def</span> <span class="token function">plot</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> point <span class="token keyword">in</span> points<span class="token punctuation">:</span>        x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>point<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>point<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    y <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>sub<span class="token punctuation">,</span> <span class="token punctuation">[</span>max<span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将所有点的 y 轴坐标修改为与最高点的距离</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">'co'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        i <span class="token operator">=</span> path<span class="token punctuation">[</span>_ <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        j <span class="token operator">=</span> path<span class="token punctuation">[</span>_<span class="token punctuation">]</span>        plt<span class="token punctuation">.</span>arrow<span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span> length_includes_head<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 前两个坐标为箭头尾坐标，后两个是箭头的长度和方向</span>    plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1.1</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1.1</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运筹学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树/前缀树(Trie)</title>
      <link href="/2023/03/21/%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91-Trie/"/>
      <url>/2023/03/21/%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91-Trie/</url>
      
        <content type="html"><![CDATA[<h3 id="字典树-x2F-前缀树（Trie）"><a href="#字典树-x2F-前缀树（Trie）" class="headerlink" title="字典树/前缀树（Trie）"></a>字典树/前缀树（Trie）</h3><p><strong>介绍</strong></p><p>Trie（又称字典树、前缀树）是一种树形数据结构，用于高效地存储和检索字符串数据集。Trie 的每个节点代表一个字符串的字符，从根节点到叶子节点的路径表示一个完整的字符串。</p><p>Trie 的主要特点是将相同前缀的字符串合并在一起，因此它通常被用于实现自动补全、单词拼写检查和 IP 地址路由等应用场景。</p><p>Trie 的基本操作包括插入字符串、查找字符串、删除字符串等。插入一个字符串时，从根节点开始，根据字符串中每个字符所代表的节点逐层向下遍历，直到字符串的最后一个字符被插入为止。查找一个字符串时，也是从根节点开始，根据字符串中每个字符所代表的节点逐层向下遍历，如果能够遍历到字符串的最后一个字符所在的节点，则表示字符串存在于 Trie 中。</p><p>Trie 的时间复杂度取决于字符串的长度和 Trie 中包含的字符串数量。在最坏情况下，时间复杂度为 O(mn)，其中 m 是字符串的平均长度，n 是字符串的数量。但是，在实际应用中，Trie 的性能通常比较高效，特别是对于大量具有相同前缀的字符串。</p><p><strong>Trie的存储</strong></p><p>存储方式如图所示，从根节点开始，如果需要的字符不存在那么就创造一个新的点来存储这个字符，另外每个字符串结尾需要做上标记。做标记是为了查找时方便。例如Trie树中存储有abcdef这个字符串，但是没有abc这个字符串。如果输入完一个字符串以后不加上一个标记在查找abc这个字符串是可以找到的，这就出现了问题。</p><p><img src="/images/%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91-Trie/image-20230321223556291.png" alt="Trie树"></p><p><strong>Trie查找</strong></p><p>和存储类似，要在查找的最后一个字符之后看是否有标记，没有标记那么不存在该字符。</p><p><strong>代码</strong></p><p>Acwing 题目：Trie 字符串统计</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> son<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 最多存26个字母, 下标为 0 的点，既是根节点，又是空结点</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 初始从根节点开始</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>idx<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 查看该结点下有没有该字符，没有该字符那就创建出来 </span>        p <span class="token operator">=</span> son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 以这个点结尾的单词数量多了一个</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> op<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s%s"</span><span class="token punctuation">,</span> op<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>op<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'I'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">insert</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">query</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒子群算法</title>
      <link href="/2023/03/21/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/21/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="粒子群优化（PSO）"><a href="#粒子群优化（PSO）" class="headerlink" title="粒子群优化（PSO）"></a>粒子群优化（PSO）</h3><p><strong>1. 简介</strong></p><p>受到鸟群觅食行为的规律性启发，经过多年改进最终形成了<strong>粒子群算法</strong>。</p><p><strong>2. 特点</strong></p><p>粒子群算法具有收敛速度快、参数少、算法简单易实现的优点（对高纬度优化问题，比遗传算法更快收敛于最优解），但是也会存在陷入局部最优解的问题。</p><p><strong>3. 基本思想</strong></p><p>鸟群通过集体的信息共享使群体找到最优的目的地。鸟群在森林中随机搜索食物，它们想要找到食物量最多的位置。但是所有的鸟都不知道食物的具体位置，每只鸟都会跟着自己判断的方向进行搜索，并在搜索过程中记录自己曾经找到过食物且量最多的位置。同时所有鸟都共享自己每一次发现食物的位置以及食物的量，这样整个鸟群就知道找到的最多食物的位置和食物量。每只鸟在找食物的过程中，都会根据自己记忆中食物量最多的位置和当前鸟群记录的食物量最多的位置调整自己接下来的方向。</p><p><strong>4. 粒子的两个属性</strong></p><p>（1）速度：粒子下一次迭代时移动的方向和距离。 （2）位置</p><p><strong>5. 算法的6个重要参数</strong></p><p>​假设在 $D$ 维搜索空间中，有 $N$ 个粒子，每个粒子代表一个解。</p><p>（1）第 $i$ 个粒子的位置：</p><p>​$X_{id} = (x_{i1}, x_{i2}…,x_{1D})$</p><p>（2）第 $i$ 个粒子的速度：</p><p>​$V_{id} = (v_{i1}, v_{i2}…,v_{iD})$</p><p>（3）第 $i$ 个粒子搜索到的最优位置（个体最优）：</p><p>​$P_{id, pbest} = (p_{i1}, p_{i2}…,p_{iD})$ </p><p>（4）群体搜索到的最优位置（群体最优）：</p><p>​$P_{d, gbest} = (p_{1,gbest}, p_{2,gbest}…,p_{D,gbest})$</p><p>（5）第 $i$ 个粒子最优位置的适应值：$f_{p}$</p><p>（6）群体搜索到的最优位置的适应值：$f_{g}$ </p><p><strong>6. 算法的伪代码</strong></p><p><img src="/images/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/v2-f808e7b6071e084fdcff0e27ad106722_720w.webp" alt="粒子群算法伪代码"></p><p><strong>7. 速度更新公式</strong></p><p>粒子下一步迭代的速度方向</p><p>$ v_{id}^{k+1} = w v_{id}^{k} + c_{1}r_{1}(p^{k}<em>{id, pbest} - x</em>{id}^{k}) + c_{2}r_{2}(p_{d, gbest}^{k} - x^{k}_{id}) $ </p><p>其中，$i$ 是粒子序号，$d$ 是粒子维度，$k$ 是迭代轮次，$w$ 是惯性权重，$c_{1}$ 是个体学习因子，$c_{2}$ 是种群学习因子，$r_{1}、r_{2}$ 是 [0, 1] 之间的随机数，增加搜索的随机性。</p><p>（1）$wv_{id}^{k}$  表示的是第 $k$ 轮速度的惯性部分。</p><p>（2）$p_{i, pbest}^{k} - x_{i}^{k}$  表示的是第 $k$ 轮迭代时，从当前点到粒子 $i$ 所找到的个体最优点的方向，是一个向量。</p><p>（3）$p_{gbest}^{k} - x_{i}^{k}$  表示的是第 $k$ 轮迭代时，从当前点到群体最优点的方向，也是一个向量。 </p><p>也就是说，粒子的下一次迭代的方向 = 惯性方向 + 个体最优方向 + 群体最优方向</p><p><strong>8. 位置更新公式</strong></p><p>$x_{id}^{k+1} = x_{id}^{k} + v_{id}^{k+1}$ </p><p><strong>9. 粒子群算法的一些参数解释：</strong></p><p>（1）粒子群规模：$N$，复杂的问题一般取较大的值，较小的问题就设小一点。这个值如果比较小的话，会陷入局部最优解，设大的话更容易找到全局最优解，但是每一次的迭代计算量会比较大。</p><p>（2）粒子的维度：$D$</p><p>（3）迭代次数：$K$, 推荐范围 [50, 100]。</p><p>（4）惯性权重：$w$ ，$w$ 值越大，探索新区域的能力越强，全局寻优能力越强，但局部寻优能力越弱。反之，全局寻优能力越弱，局部寻优能力强。较大的 $w$ 有利于全局搜索，跳出局部极值，不至于陷入局部最优；而较小的 $w$ 有利于局部搜索，让算法快速收敛到最优解。当问题空间较大时，为了在搜索速度和搜索精度之间达到平衡，通常做法是使算法在前期有较高的全局搜索能力以得到合适的种子，而在后期有较高的局部搜索能力以提高收敛精度，所以 $w$ 不宜为一个固定的常数。</p><p>（5）学习因子：$c_{1}, c_{2}$</p><p>​也称为加速系数或加速因子。</p><ul><li>$c_{1}$ 表示粒子下一步动作来源于自身经验部分所占的权重，将粒子推向个体最优位置的加速权重。</li><li>$c_{2}$ 表示粒子下一步动作来源于其他粒子经验部分所占权重，将例子推向群体最优位置的加速权重。</li></ul><p><strong>10. 算法注意事项</strong></p><p>​$v_{max}$ 较大时，粒子飞行速度快，探索能力强，但容易飞过最优解。</p><p>​$v_{max}$ 较小时，飞行速度慢，开发能力强，但是收敛速度慢，且容易陷入局部最优解。</p><p>​$v_{max}$ 一般设为粒子变化范围的 10%~20%，可根据实际情况调试，但不能大于粒子的变化范围。</p><p><strong>11. 用python实现粒子群算法</strong></p><p>以优化 $y = x^{2} - 4x + 3$ 为例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> random<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">class</span> <span class="token class-name">PSO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pN<span class="token punctuation">,</span> dim<span class="token punctuation">,</span> max_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>w <span class="token operator">=</span> <span class="token number">0.8</span>        self<span class="token punctuation">.</span>c1 <span class="token operator">=</span> <span class="token number">2</span>        self<span class="token punctuation">.</span>c2 <span class="token operator">=</span> <span class="token number">2</span>        self<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">0.6</span>        self<span class="token punctuation">.</span>r2 <span class="token operator">=</span> <span class="token number">0.3</span>        self<span class="token punctuation">.</span>pN <span class="token operator">=</span> pN      <span class="token comment" spellcheck="true"># 粒子数量</span>        self<span class="token punctuation">.</span>dim <span class="token operator">=</span> dim    <span class="token comment" spellcheck="true"># 搜索维度</span>        self<span class="token punctuation">.</span>max_iter <span class="token operator">=</span> max_iter  <span class="token comment" spellcheck="true"># 迭代次数</span>        self<span class="token punctuation">.</span>X <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>pN<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 所有粒子的位置和速度</span>        self<span class="token punctuation">.</span>V <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>pN<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span><span class="token punctuation">)</span>           self<span class="token punctuation">.</span>pbest <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>pN<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 每个粒子当前的个体最优解</span>        self<span class="token punctuation">.</span>gbest <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 种群最优解</span>        self<span class="token punctuation">.</span>p_fit <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>self<span class="token punctuation">.</span>pN<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true"># 每个个体的历史最佳适应值</span>        self<span class="token punctuation">.</span>fit <span class="token operator">=</span> <span class="token number">1e10</span>                              <span class="token comment" spellcheck="true"># 全局最佳适应值</span>        <span class="token comment" spellcheck="true"># 目标函数</span><span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> X<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token operator">*</span>X <span class="token operator">+</span> <span class="token number">3</span><span class="token comment" spellcheck="true"># 初始化种群</span><span class="token keyword">def</span> <span class="token function">init_Population</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>pN<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 随机的位置</span>            self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 随机的速度</span>        self<span class="token punctuation">.</span>pbest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                          tmp <span class="token operator">=</span> self<span class="token punctuation">.</span>function<span class="token punctuation">(</span>self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 初始解的适应度值</span>        self<span class="token punctuation">.</span>p_fit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp       <span class="token comment" spellcheck="true"># 第 i 个粒子的适应度值</span>        <span class="token keyword">if</span> tmp <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>fit<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>fit <span class="token operator">=</span> tmp            self<span class="token punctuation">.</span>gbest <span class="token operator">=</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 更新粒子位置</span><span class="token keyword">def</span> <span class="token function">iterator</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    fitness <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 当前的解能够更新个体最优和群体最优</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>pN<span class="token punctuation">)</span><span class="token punctuation">:</span>            temp <span class="token operator">=</span> self<span class="token punctuation">.</span>function<span class="token punctuation">(</span>self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> temp <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>p_fit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 更新个体最优</span>                self<span class="token punctuation">.</span>p_fit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp                self<span class="token punctuation">.</span>pbest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>p_fit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>fit<span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 更新全局最优</span>                    self<span class="token punctuation">.</span>gbest <span class="token operator">=</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    self<span class="token punctuation">.</span>fit <span class="token operator">=</span> self<span class="token punctuation">.</span>p_fit<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 根据当前解更新下一迭代的解</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>pN<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>w <span class="token operator">*</span> self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>c1 <span class="token operator">*</span> self<span class="token punctuation">.</span>r1 <span class="token operator">*</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>pbest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>c2<span class="token operator">*</span>self<span class="token punctuation">.</span>r2<span class="token operator">*</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>gbest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>X<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>V<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        fitness<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fit<span class="token punctuation">)</span>    <span class="token keyword">return</span> fitness<span class="token comment" spellcheck="true"># 程序执行</span>my_pso <span class="token operator">=</span> PSO<span class="token punctuation">(</span>pN <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>my_pso<span class="token punctuation">.</span>init_Population<span class="token punctuation">(</span><span class="token punctuation">)</span>fitness <span class="token operator">=</span> my_pso<span class="token punctuation">.</span>iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画图</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Figure1"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"iterators"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">14</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"fitness"</span><span class="token punctuation">,</span>size<span class="token operator">=</span><span class="token number">14</span><span class="token punctuation">)</span>t <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>t <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fitness <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>fitness<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>t<span class="token punctuation">,</span> fitness<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考原文：<a href="https://zhuanlan.zhihu.com/p/346355572">https://zhuanlan.zhihu.com/p/346355572</a></p>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运筹学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变邻域搜索算法</title>
      <link href="/2023/03/20/%E5%8F%98%E9%82%BB%E5%9F%9F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/20/%E5%8F%98%E9%82%BB%E5%9F%9F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="变邻域搜索算法（Variable-Neighborhood-Search）"><a href="#变邻域搜索算法（Variable-Neighborhood-Search）" class="headerlink" title="变邻域搜索算法（Variable Neighborhood Search）"></a>变邻域搜索算法（Variable Neighborhood Search）</h3><p><strong>1. 邻域和邻域动作：</strong></p><p><strong>邻域：</strong>所谓邻域，简单的说就是给定点附近其他点的集合。在距离空间中，邻域一般定义为以给定点为圆心的一个圆；而在组合优化问题中，邻域就是指对当前解进行一个操作（这个操作可以称之为邻域动作）可以得到的所有解的集合。那么不同邻域的本质区别在于邻域动作的不同。</p><p><strong>邻域动作：</strong>领域动作是一个函数，通过这个函数对当前解进行转换，产生其相应的邻居解的集合。例如，在 TSP 问题中，给定一个表示城市访问顺序的向量 s = {1，2，3，4}, 而其邻域动作为交换两个城市的位置，那么 s 的邻域为 [[2，1，3，4]，[3，2，1，4]，[4，2，3，1]，[1，3，2，4]，[1，4，3，2]，[1，2，4，3]]。</p><p><strong>2. 变领域算法</strong></p><p>​变领域算法主要由以下两个部分组成：</p><ul><li>Variable Neighborhood Descent</li></ul><p>​过程如下：</p><p>​（1）给定初始解 $S$ ，可以定义多个邻域动作，记为 $N_{k}(k = 1,2,3…m)$ ，每个邻域动作其实都会应一个邻域，并且从 $ i = 1$ 的邻域开始。</p><p>​（2）使用邻域结构 $N_{i}$ 进行搜索，如果在该邻域内找到一个比 S 更优的解 $S^{‘}$, 那么令 $S = S^{‘}, i = 1$。</p><p>​（3）如果邻域 $N_{i}$ 找不到比 $S$ 更优的解，那么令 $i++$ 。</p><p>​（4）如果 $i\le m$ , 转到步骤 2 继续。</p><p>​（5）输出最优解 $S$ 。</p><ul><li>Shaking Procedure</li></ul><p>​这个过程在本质上和邻域动作没什么区别，但是我认为 Shaking 的过程能让解偏离的更远，更容易找到局部最优解，在这个过程过后，就是将该解使用 VND 来找到该点所有邻域下的局部最优解。</p><p>​这个 Shaking 过程如果连续很多次都历史最优解都没有发生变化，那么认为已经是找到了全局最优解了。</p><p><strong>3. 变邻域算法求解 TSP 代码</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -- coding: utf-8 --</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> time<span class="token comment" spellcheck="true"># 读取城市的 x, y 坐标</span><span class="token keyword">def</span> <span class="token function">load</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">:</span>    f <span class="token operator">=</span> open<span class="token punctuation">(</span>txt<span class="token punctuation">)</span>    map <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    flag <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>        line <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> line <span class="token operator">==</span> <span class="token string">"NODE_COORD_SECTION"</span><span class="token punctuation">:</span>            flag <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">continue</span>        <span class="token keyword">if</span> line <span class="token operator">==</span> <span class="token string">"EOF"</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token keyword">if</span> flag<span class="token punctuation">:</span>            a <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>            map<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>float<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> float<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> tuple<span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取两个城市之间的二维欧几里得距离</span><span class="token keyword">def</span> <span class="token function">getDist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> map<span class="token punctuation">,</span> size    dist <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>            dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> map<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> map<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> disttxt <span class="token operator">=</span> <span class="token string">"st70.tsp"</span>map <span class="token operator">=</span> load<span class="token punctuation">(</span>txt<span class="token punctuation">)</span>size <span class="token operator">=</span> len<span class="token punctuation">(</span>map<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 城市数量</span>visited <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>solutions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>DIST <span class="token operator">=</span> getDist<span class="token punctuation">(</span><span class="token punctuation">)</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 根据路径获取该路径总代价</span><span class="token keyword">def</span> <span class="token function">getCost</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    cost <span class="token operator">=</span> <span class="token number">0</span>    former <span class="token operator">=</span> path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> city <span class="token keyword">in</span> path<span class="token punctuation">:</span>        cost <span class="token operator">+=</span> DIST<span class="token punctuation">[</span>former<span class="token punctuation">]</span><span class="token punctuation">[</span>city<span class="token punctuation">]</span>        former <span class="token operator">=</span> city    cost <span class="token operator">+=</span> DIST<span class="token punctuation">[</span>path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>path<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> cost<span class="token comment" spellcheck="true"># 扰动产生新的随机解，扰动方式：分成四个区间随机排序</span><span class="token comment" spellcheck="true"># 当前解的所有领域内都不能再更新当前解时，就是说当前解已经到达局部最优，且没法跳出局部最优</span><span class="token comment" spellcheck="true"># 这时，加入 shaking 操作，让其产生一个新解，这个解可能引导找到一个全局最优解</span><span class="token keyword">def</span> <span class="token function">shaking</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> size    ini <span class="token operator">=</span> visited<span class="token punctuation">[</span>path<span class="token punctuation">]</span>     <span class="token comment" spellcheck="true"># 初始的 cost</span>    cnt <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        pos1<span class="token punctuation">,</span> pos2<span class="token punctuation">,</span> pos3 <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        path_ <span class="token operator">=</span> path<span class="token punctuation">[</span>pos1<span class="token punctuation">:</span>pos2<span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span>pos1<span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>pos3<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>pos2<span class="token punctuation">:</span>pos3<span class="token punctuation">]</span>        <span class="token keyword">if</span> path_ <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>            cost <span class="token operator">=</span> getCost<span class="token punctuation">(</span>path_<span class="token punctuation">)</span>            visited<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>path_<span class="token punctuation">:</span> cost<span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            cost <span class="token operator">=</span> visited<span class="token punctuation">[</span>path_<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 不论这个解是否在 visited 中，它的 cost 都被记录下来</span>        cnt <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> ini <span class="token operator">>=</span> cost<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 如果这个解比当前解好，就不用找了，退出</span>            <span class="token keyword">break</span>        <span class="token keyword">elif</span> cnt <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 如果都找了 100 次都没有找到比当前解好的解，那就还是用当前解</span>            path_ <span class="token operator">=</span> path            cost <span class="token operator">=</span> ini            <span class="token keyword">break</span>    <span class="token keyword">return</span> path_<span class="token comment" spellcheck="true"># 下面是三种获取邻域的方式</span><span class="token comment" spellcheck="true"># 反转一段区间，获取新领域</span><span class="token keyword">def</span> <span class="token function">getNei_rev</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> size    min <span class="token operator">=</span> visited<span class="token punctuation">[</span>path<span class="token punctuation">]</span>    cnt <span class="token operator">=</span> <span class="token number">0</span>    cost <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>size<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        path_ <span class="token operator">=</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> path_ <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>            cost <span class="token operator">=</span> getCost<span class="token punctuation">(</span>path_<span class="token punctuation">)</span>            visited<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>path_<span class="token punctuation">:</span> cost<span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            cost <span class="token operator">=</span> visited<span class="token punctuation">[</span>path_<span class="token punctuation">]</span>        cnt <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 比当前解好退出</span>        <span class="token keyword">if</span> cost <span class="token operator">&lt;</span> min<span class="token punctuation">:</span>            min <span class="token operator">=</span> cost            <span class="token keyword">break</span>        <span class="token keyword">elif</span> cnt <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 很难找到比当前解好的解</span>            path_ <span class="token operator">=</span> path            <span class="token keyword">break</span>    <span class="token keyword">return</span> path_<span class="token punctuation">,</span> min<span class="token comment" spellcheck="true"># 交换两个城市</span><span class="token keyword">def</span> <span class="token function">getNei_exc</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> size    min <span class="token operator">=</span> visited<span class="token punctuation">[</span>path<span class="token punctuation">]</span>    cnt <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        i<span class="token punctuation">,</span>j <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>size<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        path_ <span class="token operator">=</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>j<span class="token punctuation">:</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> path_ <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>            cost <span class="token operator">=</span> getCost<span class="token punctuation">(</span>path_<span class="token punctuation">)</span>            visited<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>path_<span class="token punctuation">:</span>cost<span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            cost <span class="token operator">=</span> visited<span class="token punctuation">[</span>path_<span class="token punctuation">]</span>        cnt<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">if</span> cost <span class="token operator">&lt;</span> min<span class="token punctuation">:</span>            min <span class="token operator">=</span> cost            <span class="token keyword">break</span>        <span class="token keyword">elif</span> cnt <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">:</span>            path_ <span class="token operator">=</span> path            <span class="token keyword">break</span>    <span class="token keyword">return</span> path_<span class="token punctuation">,</span> min<span class="token comment" spellcheck="true"># 随机挑选两个城市插入序列头部，获取新邻域</span><span class="token keyword">def</span> <span class="token function">getNei_ins</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> size    min <span class="token operator">=</span> visited<span class="token punctuation">[</span>path<span class="token punctuation">]</span>    cnt <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        i<span class="token punctuation">,</span>j <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>size<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        path_ <span class="token operator">=</span> path<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>j<span class="token punctuation">:</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> path<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> path_ <span class="token operator">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>            cost <span class="token operator">=</span> getCost<span class="token punctuation">(</span>path_<span class="token punctuation">)</span>            visited<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>path_<span class="token punctuation">:</span>cost<span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            cost <span class="token operator">=</span> visited<span class="token punctuation">[</span>path_<span class="token punctuation">]</span>        cnt<span class="token operator">+=</span><span class="token number">1</span>        <span class="token keyword">if</span> cost <span class="token operator">&lt;</span> min<span class="token punctuation">:</span>            min <span class="token operator">=</span> cost            <span class="token keyword">break</span>        <span class="token keyword">elif</span> cnt <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">:</span>            path_ <span class="token operator">=</span> path            <span class="token keyword">break</span>    <span class="token keyword">return</span> path_<span class="token punctuation">,</span><span class="token comment" spellcheck="true"># 在Local Search中使用 VND 方法进行搜索</span><span class="token keyword">def</span> <span class="token function">VND</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    l <span class="token operator">=</span> <span class="token number">0</span>    min <span class="token operator">=</span> visited<span class="token punctuation">[</span>path<span class="token punctuation">]</span>    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            path_<span class="token punctuation">,</span> cost <span class="token operator">=</span> getNei_rev<span class="token punctuation">(</span>path<span class="token punctuation">)</span>        <span class="token keyword">elif</span> l <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            path_<span class="token punctuation">,</span> cost <span class="token operator">=</span> getNei_exc<span class="token punctuation">(</span>path<span class="token punctuation">)</span>        <span class="token keyword">elif</span> l <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            path_<span class="token punctuation">,</span> cost <span class="token operator">=</span> getNei_ins<span class="token punctuation">(</span>path<span class="token punctuation">)</span>        <span class="token keyword">if</span> cost <span class="token operator">&lt;</span> min<span class="token punctuation">:</span>            path <span class="token operator">=</span> path_            min <span class="token operator">=</span> cost            l <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            l <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> path<span class="token punctuation">,</span> min<span class="token comment" spellcheck="true"># 进行变邻域局部搜素</span><span class="token keyword">def</span> <span class="token function">VNS</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> kmax<span class="token punctuation">)</span><span class="token punctuation">:</span>    k <span class="token operator">=</span> <span class="token number">0</span>    temp <span class="token operator">=</span> path          <span class="token comment" spellcheck="true"># 初始化路径</span>    min <span class="token operator">=</span> solutions<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 初始化路径的 cost</span>    <span class="token keyword">global</span> count    <span class="token keyword">while</span> k <span class="token operator">&lt;</span> kmax<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># kmax 次shaking</span>        path_nei<span class="token punctuation">,</span> cost <span class="token operator">=</span> VND<span class="token punctuation">(</span>shaking<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 将 temp 这个解产生一个变化大的新解（shaking操作），然后进行 VND 局部搜索</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>cost<span class="token punctuation">)</span>                              <span class="token comment" spellcheck="true"># 当前局部搜索的最优路径的 cost</span>        solutions<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cost<span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true"># 该局部邻域能够搜索的最优解</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> cost <span class="token operator">&lt;</span> min<span class="token punctuation">:</span>                           <span class="token comment" spellcheck="true"># 该 shaking 下的领域可以更新最优解</span>            temp <span class="token operator">=</span> path_nei <span class="token comment" spellcheck="true"># 记录迭代过的最优的解</span>            min <span class="token operator">=</span> cost            k <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            k <span class="token operator">+=</span> <span class="token number">1</span>                               <span class="token comment" spellcheck="true"># 直到连续 shaking 了 kmax 次都更新不了最优解时才退出</span>    <span class="token keyword">return</span> temp<span class="token punctuation">,</span> min<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    time_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">global</span> solutions<span class="token punctuation">,</span>visited<span class="token punctuation">,</span>size<span class="token punctuation">,</span>map    kmax <span class="token operator">=</span> <span class="token number">1000</span>    start <span class="token operator">=</span> tuple<span class="token punctuation">(</span><span class="token punctuation">[</span>k <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    visited<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>start<span class="token punctuation">:</span>getCost<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    solutions<span class="token punctuation">.</span>append<span class="token punctuation">(</span>visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span>    path_<span class="token punctuation">,</span>cost <span class="token operator">=</span> VNS<span class="token punctuation">(</span>start<span class="token punctuation">,</span>kmax<span class="token punctuation">)</span>    path <span class="token operator">=</span> path_<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> path_<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>    time_end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Algorithm VNS iterated'</span><span class="token punctuation">,</span>count<span class="token punctuation">,</span><span class="token string">'times!\n'</span><span class="token punctuation">,</span>sep<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'It cost '</span><span class="token punctuation">,</span>time_end<span class="token operator">-</span>time_start<span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">,</span>sep<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 此处单位为秒</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'You got the best solution:'</span><span class="token punctuation">,</span>cost<span class="token punctuation">,</span>sep<span class="token operator">=</span><span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>    best <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"The best solution should be: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"误差为："</span><span class="token punctuation">,</span><span class="token punctuation">(</span>cost<span class="token operator">-</span>best<span class="token punctuation">)</span><span class="token operator">/</span>best<span class="token punctuation">)</span>    x <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> path<span class="token punctuation">]</span><span class="token punctuation">)</span>    y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> path<span class="token punctuation">]</span><span class="token punctuation">)</span>    i <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>solutions<span class="token punctuation">)</span><span class="token punctuation">)</span>    solutions <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>solutions<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">121</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">122</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>i<span class="token punctuation">,</span>solutions<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运筹学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁忌搜索算法</title>
      <link href="/2023/03/18/%E7%A6%81%E5%BF%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/18/%E7%A6%81%E5%BF%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="禁忌搜索（Tabu-Search）算法"><a href="#禁忌搜索（Tabu-Search）算法" class="headerlink" title="禁忌搜索（Tabu Search）算法"></a>禁忌搜索（Tabu Search）算法</h3><h4 id="TS主要构成要素"><a href="#TS主要构成要素" class="headerlink" title="TS主要构成要素"></a>TS主要构成要素</h4><ol><li>领域：简单地说就是给定点附近其他点的集合。领域就是指对当前解进行一个操作（这个操作称之为领域动作）可以得到的所有解的集合。</li><li>领域动作：领域动作是一个函数，通过这个函数，对当前解s，产生其相应的领居解集合。</li><li>禁忌表：<ol><li>禁忌对象：由于需要避免一些操作的重复进行，就要将一些元素放到禁忌表中以禁止对这些元素进行操作，这些元素就是我们指的紧急对象（通常指找到的局部最优解）。</li><li>禁忌长度：禁忌长度是被禁对象不允许选取的迭代次数。一般是给被禁对象 x 一个数（禁忌长度）t，要求对象 x 在 t 步迭代内被禁止</li></ol></li><li>候选集合：候选集合由邻域中的邻居组成，常规方法是从邻域中选择若干个目标函数取值最佳的加入集合</li><li>评价函数：评价候选集合元素选取的一个评价公式。</li><li>特赦规则：在禁忌搜索算法迭代过程中，会出现候选集中全部对象都被禁忌，或有一对象被禁，但若解禁则其目标值将有非常大的下降情况。这种情况为了达到全局最优，我们会让一些禁忌对象重新可选。这种方法称为特赦，相应的规则称为特赦规则。</li></ol><h4 id="TS算法流程"><a href="#TS算法流程" class="headerlink" title="TS算法流程"></a>TS算法流程</h4><ol><li>禁忌表 H = 空集，并选定一个初始解 $x_{1}$ ;</li><li>在 $x_{i}$ 的邻域 $N(x_{i})$ 中选择候选集 $Can_N(x_{i})$ ；在 $Can_N(x_{i})$ 中选择一个评价值最佳的解 $x_{i+1}$ ，这个 $x_{i+1}$ 不会和 $x_{i}$ 进行比较，这就有助于跳出局部最优解。<ul><li>$x_{i+1}$ 不在禁忌表中，选为当前解。</li><li>$x_{i+1}$ 在禁忌表中，满足破禁条件（即优于当前搜索中的最优解），$x_{i+1}$ 为当前解，否则选择一个不在禁忌表中的次优解。</li></ul></li><li>重复步骤 2 ，直到满足条件为止（一般终止条件为是否达到一定的迭代次数或者达到了一个时间限制）。</li></ol><h4 id="禁忌搜索求解TSP问题"><a href="#禁忌搜索求解TSP问题" class="headerlink" title="禁忌搜索求解TSP问题"></a>禁忌搜索求解TSP问题</h4><p>假设禁忌长度设为 2，候选集合长度定义为 4，迭代次数为 100</p><p>给定初始解 $x_{1} = 【A,D,C,F,E,A】, f(x_{1})=10$，历史最优为 10</p><table><thead><tr><th align="center">候选集和</th><th align="center">禁忌表</th></tr></thead><tbody><tr><td align="center">【A,C,D,F,E,A】f=15</td><td align="center"></td></tr><tr><td align="center">【A,D,C,E,F,A】f =20</td><td align="center"></td></tr><tr><td align="center">【A,D,F,C,E,A】f=8</td><td align="center"></td></tr><tr><td align="center">【A,E,C,F,D,A】f=6</td><td align="center"></td></tr></tbody></table><p>我们发现对 $x_{1}$ 交换 D 和 E 时，f 最优，此时 $x_{2} = 【A,E,C,F,D,A】, f(x_{2}=6)$, 历史最优为 6， 将 DE 放入禁忌表。</p><table><thead><tr><th align="center">候选集合</th><th align="center">禁忌表</th></tr></thead><tbody><tr><td align="center">【A,E,F,C,D,A】f=9</td><td align="center">D-E</td></tr><tr><td align="center">【A,F,C,E,D,A】f=15</td><td align="center"></td></tr><tr><td align="center">【A,C,E,F,D,A】f=6</td><td align="center"></td></tr><tr><td align="center">【A,E,D,F,C,A】f=5</td><td align="center"></td></tr></tbody></table><p>对 $x_{2}$ 交换 D 和 C 时，f 最优，此时 $x_{3} = 【A,E,D,F,C,A】,f(x_{3})=5$ , 历史最优为 5，将 DC 加入到禁忌表中。</p><table><thead><tr><th align="center">候选集合</th><th align="center">禁忌表</th></tr></thead><tbody><tr><td align="center">【A,E,C,F,D,A】f=8</td><td align="center">D-E</td></tr><tr><td align="center">【A,E,F,D,C,A】f=10</td><td align="center">D-C</td></tr><tr><td align="center">【A,E,D,C,F,A】f=14</td><td align="center"></td></tr><tr><td align="center">【A,C,D,F,E,A】 f=16</td><td align="center"></td></tr></tbody></table><p>此时，最优的是将 $x_{3}$ 中的 D 和 C 交换，但由于D-C 在禁忌表中，因此我们退而求其次，对 $x_{3}$ 交换 F 和 D, 此时得到 $x_{4}=【A,E,F,D,C,A】,f(x_{4}) = 10$ ，历史最优为 5，将 F-D 放入禁忌表，由于禁忌表长度为 2，所以要将 D-E 移出禁忌表，再将 F-D放入。</p><table><thead><tr><th align="center">候选集合</th><th align="center">禁忌表</th></tr></thead><tbody><tr><td align="center">【A,E,F,C,D,A】f=4</td><td align="center">D-C</td></tr><tr><td align="center">【A,E,C,D,F,A】f=5</td><td align="center">F-D</td></tr><tr><td align="center">【A,F,E,D,C,A】f=7</td><td align="center"></td></tr><tr><td align="center">【A,C,F,D,E,A】 f=10</td><td align="center"></td></tr></tbody></table><p>这里 $x_{4}$ 交换 C-D，得到了 $x_{5}$，这里 C-D 是在禁忌表中的，但由于 $f(x_{5})=4$ 比当前历史最优的还要小，满足特赦规则。然后再将 C-D 重新加入禁忌表中。</p><table><thead><tr><th align="center">候选集合</th><th align="center">禁忌表</th></tr></thead><tbody><tr><td align="center">【A,C,F,E,D,A】f=5</td><td align="center">D-F</td></tr><tr><td align="center">【A,E,C,F,D,A】f=7</td><td align="center">C-D</td></tr><tr><td align="center">【A,D,F,C,E,A】f=9</td><td align="center"></td></tr><tr><td align="center">【A,F,E,C,D,A】 f=29</td><td align="center"></td></tr></tbody></table><p>依次迭代，直到达到停止条件。</p><h4 id="禁忌搜索解TSP代码"><a href="#禁忌搜索解TSP代码" class="headerlink" title="禁忌搜索解TSP代码"></a>禁忌搜索解TSP代码</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -- coding: utf-8 --</span><span class="token keyword">import</span> random<span class="token keyword">import</span> math<span class="token keyword">from</span> collections <span class="token keyword">import</span> deque       <span class="token comment" spellcheck="true"># 用来模拟禁忌表</span><span class="token keyword">def</span> <span class="token function">get_cost</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> adj_mat<span class="token punctuation">,</span> sol<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>adj_mat<span class="token punctuation">[</span>sol<span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>sol<span class="token punctuation">[</span><span class="token punctuation">(</span>_<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">tnm_selection</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> adj_mat<span class="token punctuation">,</span> sol<span class="token punctuation">,</span> max_tnm<span class="token punctuation">,</span> mut_md<span class="token punctuation">,</span> tb_size<span class="token punctuation">,</span> tb_list<span class="token punctuation">,</span> fq_dict<span class="token punctuation">,</span> best_cost<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param n: 向量的数量，代表城市的个数    :param adj_mat: 邻接矩阵，用来记录每个城市之间的距离    :param sol: 当前解    :param max_tnm: 候选集合的个数    :param mut_md: [get_sol, get_delta] 突变的方法，例如，交换、2-opt    :param tb_size: 禁忌表的长度    :param tb_list: deque,禁忌表    :param fq_dict: 顶点对的访问次数    :param best_cost: 记录历史最优的解    :return:    """</span>    get_new_sol <span class="token operator">=</span> mut_md<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    get_delta <span class="token operator">=</span> mut_md<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    cost <span class="token operator">=</span> get_cost<span class="token punctuation">(</span>n<span class="token punctuation">,</span> adj_mat<span class="token punctuation">,</span> sol<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 求一个解的目标函数</span>    <span class="token comment" spellcheck="true"># delta 的作用是用于评估邻居解的质量和选择最优解</span>    best_delta_0 <span class="token operator">=</span> math<span class="token punctuation">.</span>inf    best_i_0 <span class="token operator">=</span> best_j_0 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    best_delta_1 <span class="token operator">=</span> math<span class="token punctuation">.</span>inf    best_i_1 <span class="token operator">=</span> best_j_1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_tnm<span class="token punctuation">)</span><span class="token punctuation">:</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 随机选择两个索引下标</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token keyword">if</span> i <span class="token operator">&lt;</span> j <span class="token keyword">else</span> <span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 让 i &lt; j</span>        v_1<span class="token punctuation">,</span> v_2 <span class="token operator">=</span> <span class="token punctuation">(</span>sol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sol<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span> sol<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sol<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">(</span>sol<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> sol<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        delta <span class="token operator">=</span> get_delta<span class="token punctuation">(</span>n<span class="token punctuation">,</span> adj_mat<span class="token punctuation">,</span> sol<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v_1<span class="token punctuation">,</span> v_2<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> tb_list<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 不违反禁忌规则的 delta 最小值</span>            <span class="token keyword">if</span> delta <span class="token operator">&lt;</span> best_delta_0<span class="token punctuation">:</span>                best_delta_0 <span class="token operator">=</span> delta                best_i_0 <span class="token operator">=</span> i                best_j_0 <span class="token operator">=</span> j        <span class="token keyword">else</span><span class="token punctuation">:</span>                              <span class="token comment" spellcheck="true"># 违反禁忌规则的 delta 最小值</span>            <span class="token keyword">if</span> delta <span class="token operator">&lt;</span> best_delta_1<span class="token punctuation">:</span>                best_delta_1 <span class="token operator">=</span> delta                best_i_1 <span class="token operator">=</span> i                best_j_1 <span class="token operator">=</span> j    <span class="token comment" spellcheck="true"># 找到最小的 best_delta_0 或者 best_delta_1</span>    <span class="token keyword">if</span> best_delta_1 <span class="token operator">&lt;</span> best_delta_0 <span class="token operator">and</span> cost <span class="token operator">+</span> best_delta_1 <span class="token operator">&lt;</span> best_cost<span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 满足特赦规则</span>        v_1<span class="token punctuation">,</span> v_2 <span class="token operator">=</span> <span class="token punctuation">(</span>sol<span class="token punctuation">[</span>best_i_1<span class="token punctuation">]</span><span class="token punctuation">,</span> sol<span class="token punctuation">[</span>best_j_1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span> sol<span class="token punctuation">[</span>best_i_1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sol<span class="token punctuation">[</span>best_j_1<span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">(</span>sol<span class="token punctuation">[</span>best_j_1<span class="token punctuation">]</span><span class="token punctuation">,</span> sol<span class="token punctuation">[</span>best_i_1<span class="token punctuation">]</span><span class="token punctuation">)</span>        tb_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">(</span>v_1<span class="token punctuation">,</span> v_2<span class="token punctuation">)</span><span class="token punctuation">)</span>        tb_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>v_1<span class="token punctuation">,</span> v_2<span class="token punctuation">)</span><span class="token punctuation">)</span>        fq_dict<span class="token punctuation">[</span><span class="token punctuation">(</span>v_1<span class="token punctuation">,</span> v_2<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> fq_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">(</span>v_1<span class="token punctuation">,</span> v_2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 如果没有就赋值为 0 再加 1</span>        new_sol <span class="token operator">=</span> get_new_sol<span class="token punctuation">(</span>sol<span class="token punctuation">,</span> best_i_1<span class="token punctuation">,</span> best_j_1<span class="token punctuation">)</span>        new_cost <span class="token operator">=</span> cost <span class="token operator">+</span> best_delta_1    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> tb_size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            v1<span class="token punctuation">,</span> v2 <span class="token operator">=</span> <span class="token punctuation">(</span>sol<span class="token punctuation">[</span>best_j_0<span class="token punctuation">]</span><span class="token punctuation">,</span> sol<span class="token punctuation">[</span>best_j_0<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sol<span class="token punctuation">[</span>best_i_0<span class="token punctuation">]</span> <span class="token operator">&lt;</span> sol<span class="token punctuation">[</span>best_j_0<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">(</span>sol<span class="token punctuation">[</span>best_j_0<span class="token punctuation">]</span><span class="token punctuation">,</span> sol<span class="token punctuation">[</span>best_j_0<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>tb_list<span class="token punctuation">)</span> <span class="token operator">==</span> tb_size<span class="token punctuation">:</span>                tb_list<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            tb_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>v_1<span class="token punctuation">,</span> v_2<span class="token punctuation">)</span><span class="token punctuation">)</span>            fq_dict<span class="token punctuation">[</span><span class="token punctuation">(</span>v_1<span class="token punctuation">,</span> v_2<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> fq_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">(</span>v_1<span class="token punctuation">,</span> v_2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        new_sol <span class="token operator">=</span> get_new_sol<span class="token punctuation">(</span>sol<span class="token punctuation">,</span> best_i_0<span class="token punctuation">,</span> best_j_0<span class="token punctuation">)</span>        new_cost <span class="token operator">=</span> cost <span class="token operator">+</span> best_delta_0    <span class="token keyword">return</span> new_sol<span class="token punctuation">,</span> new_cost<span class="token punctuation">,</span> tb_list<span class="token punctuation">,</span> fq_dict<span class="token keyword">def</span> <span class="token function">tb</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> adj_mat<span class="token punctuation">,</span> tb_size<span class="token punctuation">,</span> max_tnm<span class="token punctuation">,</span> mut_md<span class="token punctuation">,</span> term_count<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param n:    :param adj_mat:    :param tb_size:    :param max_tnm:    :param mut_md:    :param term_count: 经过 term_count 迭代后就退出    :return:    """</span>    sol <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>sol<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 打乱</span>    tb_list <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    fq_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    best_sol <span class="token operator">=</span> sol<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>    best_cost <span class="token operator">=</span> get_cost<span class="token punctuation">(</span>n<span class="token punctuation">,</span> adj_mat<span class="token punctuation">,</span> sol<span class="token punctuation">)</span>    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'cost'</span><span class="token punctuation">:</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'best_cost'</span><span class="token punctuation">:</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        sol<span class="token punctuation">,</span> cost<span class="token punctuation">,</span> tb_list<span class="token punctuation">,</span> fq_dict <span class="token operator">=</span> tnm_selection<span class="token punctuation">(</span>n<span class="token punctuation">,</span> adj_mat<span class="token punctuation">,</span> sol<span class="token punctuation">,</span> max_tnm<span class="token punctuation">,</span> mut_md<span class="token punctuation">,</span> tb_size<span class="token punctuation">,</span> tb_list<span class="token punctuation">,</span> fq_dict<span class="token punctuation">,</span> best_cost<span class="token punctuation">)</span>        <span class="token keyword">if</span> cost <span class="token operator">&lt;</span> best_cost<span class="token punctuation">:</span>            best_sol <span class="token operator">=</span> sol            best_cost <span class="token operator">=</span> cost            count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>        data<span class="token punctuation">[</span><span class="token string">'cost'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cost<span class="token punctuation">)</span>        data<span class="token punctuation">[</span><span class="token string">'best_cost'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>best_cost<span class="token punctuation">)</span>        <span class="token keyword">if</span> count <span class="token operator">></span> term_count<span class="token punctuation">:</span>            <span class="token keyword">break</span>    data<span class="token punctuation">[</span><span class="token string">'fq_dict'</span><span class="token punctuation">]</span> <span class="token operator">=</span> fq_dict    <span class="token keyword">return</span> best_sol<span class="token punctuation">,</span> best_cost<span class="token punctuation">,</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运筹学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火算法（Simulated Annealing）</title>
      <link href="/2023/03/17/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95%EF%BC%88Simulated-Annealing%EF%BC%89/"/>
      <url>/2023/03/17/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95%EF%BC%88Simulated-Annealing%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="模拟退火算法（Simulated-Annealing）"><a href="#模拟退火算法（Simulated-Annealing）" class="headerlink" title="模拟退火算法（Simulated Annealing）"></a>模拟退火算法（Simulated Annealing）</h3><ol><li>求一个给定函数的最值问题</li></ol><p>$y = 11sinx + 7cos(5x)$ ，在$[-3,3]$内的最大值，暴力搜索，如果某个函数有30个变量呢？暴力搜索的时间复杂度就会很高</p><p>如果要求最小值，那么久将函数添加负号即可转换为求最小值问题</p><ol start="2"><li>蒙特卡洛模拟（这里用其求解最值问题）</li></ol><p>​思想：随机生成很多组解，验证这些解是否满足条件，若满足则将其保存到一个 “可行集” 中，然后计算这个可行集内每个解对应的目标函数值，在里面找到最值即可。</p><p>和穷举法的区别：穷举法是按一定规则来穷举整个空间，蒙特卡洛模拟是随机搜索，这是两者的区别。</p><ol start="3"><li>启发式搜索简单总结为下面两点：<ul><li>任何有助于找到问题的最优解，但不能保证找到最优解的方法均是启发式方法</li><li>有助于加速求解过程和找到较最优解的方法是启发式算法</li></ul></li><li>爬山法</li></ol><p>​<img src="/images/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95%EF%BC%88Simulated-Annealing%EF%BC%89/image-20230317204243735-167906440549012.png" alt="爬山法"></p><p>​爬山法怎么找到最大值，向周围的方向走，哪个方向会得到更大的目标函数值就往哪个方向走，直到找到一个极大值点，此时结束搜索。爬山法的缺点是很容易找到局部最优解，关键是初始值的选取，模拟退火可以解决这个问题。</p><p>​爬山法也是属于启发式算法。</p><ol start="5"><li>模拟退火算法</li></ol><p>   模拟退火会以一定的概率接收一个比当前解要差的解，此时就有几率跳出局部最优解，从而找到全局最优解。</p><p>   例子：求解 $y = 11sinx + 7cos(5x)$ ,在 $[-3,3]$ 内的最大值</p><ul><li><p>假设当前搜索到了 $x_{i}$ , 对应的函数值为 $f(x_{i})$ , 在 $x_{i}$ 附近随机找一个新的解 $x_{j}$ ，对应的函数值为 $f(x_{j})$</p><ul><li><p>如果 $f(x_{j}) &gt; f(x_{i})$ , 则接受这个新解 $x_{j}$</p></li><li><p>如果  $f(x_{j}) \le f(x_{i})$ , 以一定的概率 $p \in[0,1]$ 接受这个解，而且 $f(x_{j})$ 越接近 $f(x_{i})$ , $p$ 越大（这种想法很直观，新解和旧解的函数值越接近，那么就更愿意接受这个新解），即 $p$ 正比于 $\frac{1}{|f(x_{i})-f(x_{j})|}$ , 当 $p$ 为 0 时，等于爬山法，等于 1 时，等于蒙特卡洛模拟。</p></li></ul></li><li><p>$y = e^{-x}, x\ge 0$ 这个函数的值域在 $[0,1]$ 之间， 用该函数当作概率函数，且该函数是递减的，那么可以假设  $p \propto e^{-|f(x_{i}) - f(x_{j})|}$ </p></li><li><p>接受新解的概率 $p$ <strong>越大</strong>，意味着我们更容易接受不好的解，因此解空间的搜索范围<strong>越大</strong>。</p></li><li><p>假设搜索过程需要经过很多次迭代，在搜索前期我们的搜索范围应该尽量<strong>大</strong>，搜索后期尽量<strong>小</strong>。</p></li><li><p>因此我们概率函数 $p \propto e^{-|f(x_{i})-f(x_{j})|\times C_{t}}$，其中 $C_{t}$ 可以看作一个和时间有关的系数，因此在搜索过程中，我们接受新解的概率 $p$ 就和时间有关，显然时间<strong>越长</strong>，$C_{t}$ <strong>越 大</strong>。</p></li><li><p>问题：</p><ul><li>如果优化问题有约束条件怎么办？<ul><li>在生成新解时，判断是否满足约束条件，不满足则重新生成。</li></ul></li><li>这个 $C_{t}$ 怎么设置？<ul><li>$T_{t} = \alpha^{t}T_{0} = 100\times0.95^{t}$ ，100是初始温度，0.95是冷却系数，这都是可调参数，$T_{t}$ 随着时间增长而减小。</li><li>$C_{t} = \frac{1}{T_{t}} = \frac{1}{100\times0.95^{t}}$ ，那么 $p_{t} = e^{-\frac{|f(x_{i})-f(x_{j})|}{100\times0.95^{t}}}$</li></ul></li><li>什么时候停止搜索？<ul><li>达到指定的迭代次数</li><li>达到指定的温度，例如温度小于 0.000001，温度很低时，基本上产生新解的概率很低了</li><li>连续找到最优解 M 次，例如连续找到了 30 次</li></ul></li><li>怎么生成一个新解？<ul><li>没有统一规定，具体问题具体分析，但是要根据当前解生成一个新解，而不是随机的</li></ul></li></ul></li></ul><ol start="6"><li><p>模拟退火解TSP问题</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -- coding: utf-8 --</span><span class="token keyword">import</span> math<span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltplt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'SimHei'</span><span class="token punctuation">]</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'axes.unicode_minus'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">class</span> <span class="token class-name">SA</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_city<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>T0 <span class="token operator">=</span> <span class="token number">4000</span>            <span class="token comment" spellcheck="true"># 退火的初始温度</span>        self<span class="token punctuation">.</span>Tend <span class="token operator">=</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span>          <span class="token comment" spellcheck="true"># 温度阈值，小于等于该阈值迭代就要停止</span>        self<span class="token punctuation">.</span>rate <span class="token operator">=</span> <span class="token number">0.9995</span>        <span class="token comment" spellcheck="true"># 退火温度下降率</span>        self<span class="token punctuation">.</span>num_city <span class="token operator">=</span> num_city        self<span class="token punctuation">.</span>scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>location <span class="token operator">=</span> data      <span class="token comment" spellcheck="true"># 每个城市点的坐标</span>        self<span class="token punctuation">.</span>fires <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>dis_mat <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_dis_mat<span class="token punctuation">(</span>num_city<span class="token punctuation">,</span> data<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 求一个距离矩阵，dist[i][j] 是城市 i 到 城市 j 的距离</span>        self<span class="token punctuation">.</span>fire <span class="token operator">=</span> self<span class="token punctuation">.</span>greedy_init<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dis_mat<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>num_city<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 找到贪婪初始化下最优的一个解</span>        <span class="token comment" spellcheck="true"># 显示初始化后的路径</span>        init_pathlen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token operator">/</span> self<span class="token punctuation">.</span>compute_pathlen<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fire<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dis_mat<span class="token punctuation">)</span>        init_best <span class="token operator">=</span> self<span class="token punctuation">.</span>location<span class="token punctuation">[</span>self<span class="token punctuation">.</span>fire<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 存储每个温度下的最终路径，画出收敛图</span>        self<span class="token punctuation">.</span>iter_x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>iter_y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span> <span class="token operator">/</span> init_pathlen<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">greedy_init</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dis_mat<span class="token punctuation">,</span> num_total<span class="token punctuation">,</span> num_city<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># dis_mat:距离矩阵，num_total:一个迭代轮次要计算多少条路径， num_city: 城市数量</span>        start_index <span class="token operator">=</span> <span class="token number">0</span>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_total<span class="token punctuation">)</span><span class="token punctuation">:</span>            rest <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_city<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># 所有起点都已经生成了</span>            <span class="token keyword">if</span> start_index <span class="token operator">>=</span> num_city<span class="token punctuation">:</span>                start_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_city<span class="token punctuation">)</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>result<span class="token punctuation">[</span>start_index<span class="token punctuation">]</span><span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 初始时 start_index 从 0 增长到 num_city, 超过后随机选择一个 start_index</span>                <span class="token keyword">continue</span>            current <span class="token operator">=</span> start_index            rest<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>current<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 找到从 start_index 出发，贪心算法找到的最短路径</span>            result_one <span class="token operator">=</span> <span class="token punctuation">[</span>current<span class="token punctuation">]</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>rest<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                tmp_min <span class="token operator">=</span> math<span class="token punctuation">.</span>inf                tmp_choose <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>                <span class="token keyword">for</span> x <span class="token keyword">in</span> rest<span class="token punctuation">:</span>                    <span class="token keyword">if</span> dis_mat<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&lt;</span> tmp_min<span class="token punctuation">:</span>                        tmp_min <span class="token operator">=</span> dis_mat<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span>                        tmp_choose <span class="token operator">=</span> x                current <span class="token operator">=</span> tmp_choose                result_one<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp_choose<span class="token punctuation">)</span>                rest<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>tmp_choose<span class="token punctuation">)</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>result_one<span class="token punctuation">)</span>            start_index <span class="token operator">+=</span> <span class="token number">1</span>        pathlens <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_paths<span class="token punctuation">(</span>result<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 计算所有路径的距离</span>        sortindex <span class="token operator">=</span> np<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span>pathlens<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 找到最小值所在的下标</span>        index <span class="token operator">=</span> sortindex<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                   <span class="token comment" spellcheck="true"># 返回路径最短的那条路径</span>    <span class="token comment" spellcheck="true"># 初始化一条随机路径</span>    <span class="token keyword">def</span> <span class="token function">random_init</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_city<span class="token punctuation">)</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_city<span class="token punctuation">)</span><span class="token punctuation">]</span>        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 打乱 tmp 数组</span>        <span class="token keyword">return</span> tmp    <span class="token comment" spellcheck="true"># 计算不同城市之间的距离</span>    <span class="token keyword">def</span> <span class="token function">compute_dis_mat</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num_city<span class="token punctuation">,</span> location<span class="token punctuation">)</span><span class="token punctuation">:</span>        dis_mat <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>num_city<span class="token punctuation">,</span> num_city<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_city<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_city<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">==</span> j<span class="token punctuation">:</span>                    dis_mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>inf                    <span class="token keyword">continue</span>                a <span class="token operator">=</span> location<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                b <span class="token operator">=</span> location<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                tmp <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>sum<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> zip<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                dis_mat<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp        <span class="token keyword">return</span> dis_mat    <span class="token comment" spellcheck="true"># 计算路径长度</span>    <span class="token keyword">def</span> <span class="token function">compute_pathlen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token punctuation">,</span> dis_mat<span class="token punctuation">)</span><span class="token punctuation">:</span>        a <span class="token operator">=</span> path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        b <span class="token operator">=</span> path<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        result <span class="token operator">=</span> dis_mat<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a <span class="token operator">=</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            b <span class="token operator">=</span> path<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>            result <span class="token operator">+=</span> dis_mat<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span>        <span class="token keyword">return</span> result    <span class="token comment" spellcheck="true"># 计算一个温度下产生的一个群体的长度</span>    <span class="token keyword">def</span> <span class="token function">compute_paths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> paths<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> one <span class="token keyword">in</span> paths<span class="token punctuation">:</span>            length <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_pathlen<span class="token punctuation">(</span>one<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dis_mat<span class="token punctuation">)</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> result    <span class="token comment" spellcheck="true"># 产生一个新解：随即交换两个元素的位置</span>    <span class="token keyword">def</span> <span class="token function">get_new_fire</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fire<span class="token punctuation">)</span><span class="token punctuation">:</span>        fire <span class="token operator">=</span> fire<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        t <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>fire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># t 是下标数组</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 随机选择两个值</span>        fire<span class="token punctuation">[</span>a<span class="token punctuation">:</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> fire<span class="token punctuation">[</span>a<span class="token punctuation">:</span>b<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          <span class="token comment" spellcheck="true"># a-b 之间倒置</span>        <span class="token keyword">return</span> fire    <span class="token comment" spellcheck="true"># 退火策略，根据温度变化有一定概率接受差的解</span>    <span class="token keyword">def</span> <span class="token function">eval_fire</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> raw<span class="token punctuation">,</span> get<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        len1 <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_pathlen<span class="token punctuation">(</span>raw<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dis_mat<span class="token punctuation">)</span>        len2 <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_pathlen<span class="token punctuation">(</span>get<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dis_mat<span class="token punctuation">)</span>        dc <span class="token operator">=</span> len2 <span class="token operator">-</span> len1        p <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>dc<span class="token operator">/</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># dc 解的差，temp 是温度</span>        <span class="token keyword">if</span> len2 <span class="token operator">&lt;</span> len1<span class="token punctuation">:</span>            <span class="token keyword">return</span> get<span class="token punctuation">,</span> len2        <span class="token keyword">elif</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> p<span class="token punctuation">:</span>            <span class="token keyword">return</span> get<span class="token punctuation">,</span> len2        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> raw<span class="token punctuation">,</span> len1   <span class="token comment" spellcheck="true"># 即使有一定概率可以接受差的解，但是这里也没有接受到这个解</span>    <span class="token comment" spellcheck="true"># 模拟退火总流程</span>    <span class="token keyword">def</span> <span class="token function">sa</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 记录最优解</span>        best_path <span class="token operator">=</span> self<span class="token punctuation">.</span>fire      <span class="token comment" spellcheck="true"># 只有一个最优解</span>        best_length <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_pathlen<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fire<span class="token punctuation">,</span> self<span class="token punctuation">.</span>dis_mat<span class="token punctuation">)</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>T0 <span class="token operator">></span> self<span class="token punctuation">.</span>Tend<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 产生在这个温度下的随机解，在一个迭代轮次内应该搜索很多次，以保证搜索彻底</span>            tmp_new <span class="token operator">=</span> self<span class="token punctuation">.</span>get_new_fire<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fire<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 根据温度判断是否选择这个解</span>            self<span class="token punctuation">.</span>fire<span class="token punctuation">,</span> fire_len <span class="token operator">=</span> self<span class="token punctuation">.</span>eval_fire<span class="token punctuation">(</span>best_path<span class="token punctuation">,</span> tmp_new<span class="token punctuation">,</span> self<span class="token punctuation">.</span>T0<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 更新最优解</span>            <span class="token keyword">if</span> fire_len <span class="token operator">&lt;</span> best_length<span class="token punctuation">:</span>                best_length <span class="token operator">=</span> fire_len                best_path <span class="token operator">=</span> self<span class="token punctuation">.</span>fire            <span class="token comment" spellcheck="true"># 降低温度</span>            self<span class="token punctuation">.</span>T0 <span class="token operator">*=</span> self<span class="token punctuation">.</span>rate            <span class="token comment" spellcheck="true"># 记录收敛曲线</span>            self<span class="token punctuation">.</span>iter_x<span class="token punctuation">.</span>append<span class="token punctuation">(</span>count<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>iter_y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>best_length<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> best_length<span class="token punctuation">)</span>        <span class="token keyword">return</span> best_length<span class="token punctuation">,</span> best_path    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        best_length<span class="token punctuation">,</span> best_path <span class="token operator">=</span> self<span class="token punctuation">.</span>sa<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>location<span class="token punctuation">[</span>best_path<span class="token punctuation">]</span><span class="token punctuation">,</span> best_length<span class="token comment" spellcheck="true"># 读取数据</span><span class="token keyword">def</span> <span class="token function">read_tsp</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    lines <span class="token operator">=</span> open<span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">assert</span> <span class="token string">'NODE_COORD_SECTION\n'</span> <span class="token keyword">in</span> lines    index <span class="token operator">=</span> lines<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'NODE_COORD_SECTION\n'</span><span class="token punctuation">)</span>    data <span class="token operator">=</span> lines<span class="token punctuation">[</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> data<span class="token punctuation">:</span>        line <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'EOF'</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        tmpline <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> line<span class="token punctuation">:</span>            <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                tmpline<span class="token punctuation">.</span>append<span class="token punctuation">(</span>float<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> tmpline<span class="token punctuation">:</span>            <span class="token keyword">continue</span>        tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmpline<span class="token punctuation">)</span>    data <span class="token operator">=</span> tmp    <span class="token keyword">return</span> data<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> read_tsp<span class="token punctuation">(</span><span class="token string">"st70.tsp"</span><span class="token punctuation">)</span>    data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    show_data <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">[</span>data<span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 要回到原点</span>    Best<span class="token punctuation">,</span> Best_path <span class="token operator">=</span> math<span class="token punctuation">.</span>inf<span class="token punctuation">,</span> None    model <span class="token operator">=</span> SA<span class="token punctuation">(</span>num_city<span class="token operator">=</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    path<span class="token punctuation">,</span> path_len <span class="token operator">=</span> model<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>path_len<span class="token punctuation">)</span>    <span class="token keyword">if</span> path_len <span class="token operator">&lt;</span> Best<span class="token punctuation">:</span>        Best <span class="token operator">=</span> path_len        Best_path <span class="token operator">=</span> path    <span class="token comment" spellcheck="true"># 加上起点</span>    Best_path <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">[</span>Best_path<span class="token punctuation">,</span> Best_path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 画图</span>    fig<span class="token punctuation">,</span> axs <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sharex<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> sharey<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>Best_path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Best_path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>Best_path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Best_path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">"规划结果"</span><span class="token punctuation">)</span>    iterations <span class="token operator">=</span> model<span class="token punctuation">.</span>iter_x    best_record <span class="token operator">=</span> model<span class="token punctuation">.</span>iter_y    axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>iterations<span class="token punctuation">,</span> best_record<span class="token punctuation">)</span>    axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">"收敛曲线"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运筹学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python面向对象编程</title>
      <link href="/2023/03/17/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/03/17/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="python面向对象编程"><a href="#python面向对象编程" class="headerlink" title="python面向对象编程"></a>python面向对象编程</h1><ol><li>类和实例</li></ol><pre><code>class Student(需要继承的类)：    pass</code></pre><p>创建实例： stu = Student()</p><ol start="2"><li>初始化<br>在创建实例的时候，初始化一些属性。</li></ol><pre><code>class Student(object):    def __init__(self,name,sex):        self.name = name        self.sex = sex</code></pre><p>self 表示的是创建出来实例本身</p><ol start="2"><li><p>访问控制</p><ul><li>私有变量：只有内部可以访问，外部不能访问，如果外部要访问或者设置内部变量，可以使用get和set方法。__name 用两个下划线表示私有变量</li><li>受保护变量：外部可以访问但不建议，_name 用一个下划线表示。</li></ul></li><li><p>实例方法、类方法、静态方法</p><ul><li>实例方法的第一个参数必须为位置参数self</li><li>类方法的定义方法：在该行前面加一行<br>@classmethod<br>第一个参数必须为“类的引用cls”，</li><li>静态方法必须要在前一行加一行 @staticmethod<br>形参中没有cls和self，甚至没有任何参数。</li></ul><p>静态方法可以通过实例名也可以通过类名访问。类方法可以通过类名和实例名</p></li><li><p>继承与多态</p><ul><li>子类能继承父类的protected属性，不能继承父类private属性。</li><li>python中的每个类有很多内置的默认属性，例如：<ul><li><strong>name</strong> : 获取类名</li><li><strong>doc</strong> : 获取类的文档字符串</li><li><strong>bases</strong> : 获取类的所有父类组成的元组</li><li><strong>dict</strong> : 获取类的所有属性和方法组成的列表</li><li><strong>module</strong> : 获取类定义所在的模块名</li><li><strong>class</strong> : 获取实例对应的类</li></ul></li><li>子类和父类的同名函数，子类会覆盖父类的函数。在创建一个实例后，该实例既是父类的数据类型，也可以是子类的数据类型。</li></ul></li><li><p><strong>init__、__new__、__del</strong></p><pre><code>s1 = Student("zhang",18)</code></pre><p>如果__new__()中没有return语句，会导致创建的实例为NoneType，即s1为NoneType。<br>当__new__()执行完后才开始执行__init__()</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python读写文件</title>
      <link href="/2023/03/17/python%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/"/>
      <url>/2023/03/17/python%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="python-读写文件"><a href="#python-读写文件" class="headerlink" title="python 读写文件"></a>python 读写文件</h1><ol><li>创建/打开 文件</li></ol><ul><li><p>第一种</p><pre><code>f = open("new_file.txt", "w")   # 创建并打开f.write("some text...")         # 在文件里写东西f.close()                       # 关闭</code></pre><p>如果不指定绝对路径，那就是相对路径，文件会被创建到同级目录下。</p></li><li><p>第二种</p><pre><code>with open("new_file2.txt", "w") as f:         f.writelines(["some text for file2...\n", "2nd line\n"])</code></pre><p>这种方式好在不需要我们手动关闭文件，它会自动关闭，还有在写入数据的时候，要用\n来另起一行。</p></li><li><p>readlines() 和 readline():</p><ol><li>readlines()方法读取整个文件所有行，保存在一个列表(list)变量中，每行作为一个元素，但读取大文件会比较占内存</li><li>readline()从字面意思可以看出，该方法每次读出一行内容，所以，读取时占用内存小，比较适合大文件，该方法返回一个字符串对象。</li></ol></li></ul><ol start="2"><li>编码问题</li></ol><ul><li><p>对于不同的编码，打开文件会出现乱码，比如这个文件是 gbk 编码的，如果你不用 gbk 编码去打开文件就会出现乱码。</p></li><li><p>解决方法：</p><ol><li>弄清楚该文件的编码类型</li><li>在打开文件的时候指定用什么编码来打开( encoding )</li></ol><pre><code>with open("chinese.txt", "r", encoding="gbk") as f:  print(f.read())</code></pre></li></ul><ol start="2"><li><p>文件目录的管理（os库）</p><ul><li>当前目录：os.getcwd()</li><li>当前目录里面的文件：os.listdir()</li><li>创建文件夹：os.makedirs(), 里面有个参数 exist_ok=True,用来忽略文件已存在而产生的报错。</li><li>删除文件夹：os.removedirs() , 如果文件夹里有文件就删不掉。 </li><li>正真删除文件夹及里面的文件：shutil库<br>shutil.rmtree(“文件名”)</li><li>文件夹/文件 更名：os.rename(修改前，修改后)</li><li>判断是否是一个文件夹/文件<ul><li>os.path.isfile()：是否是一个文件</li><li>os.path.exists()：是否存在</li><li>os.path.isdir()：是否是一个目录</li></ul></li><li>创建文件副本<ul><li>os.path.basename() 获取文件名</li><li>os.path.dirname() 获取文件夹名</li><li>为副本重命名 new_file = “new_”+ os.path.basename()</li><li>将文件夹和文件连接：os.path.join( os.path.dirname , new_file )</li><li>os.path.split()：该函数的分割并不智能，它仅仅是以 “PATH” 中最后一个 ‘/‘ 作为分隔符，分隔后，将索引为0的视为目录（路径），将索引为1的视为文件名。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2023/03/17/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/17/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>维护一个next数组，next[i] = j 表示，对于一个字符串 p，p[1…i] 这个子串中，p[1….j] = p[i - j + 1, i]，即这个子串的前 j 个字符和后 j 个字符相等。</p><p>代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10010</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p 是待匹配的字符串，s是原串</span><span class="token keyword">int</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">>></span> m <span class="token operator">>></span> s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 字符串从下标 1 开始</span>    <span class="token comment" spellcheck="true">// 求 next 的过程</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 一直回退</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 如果等于，那么匹配的字符 + 1</span>        ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// kmp匹配的过程</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 匹配完成</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c">class Solution <span class="token punctuation">{</span>public<span class="token punctuation">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getNext</span><span class="token punctuation">(</span>string pattern<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">next</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// next[i] 表示的是 i-1 之前的子串的最大匹配，当 i = 0 是默认为-1</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>pattern<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>pattern<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> next <span class="token operator">=</span> <span class="token function">getNext</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>needle<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// j 表示当前匹配到的位置</span>                <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数线性规划</title>
      <link href="/2023/03/07/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
      <url>/2023/03/07/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="整数线性规划"><a href="#整数线性规划" class="headerlink" title="整数线性规划"></a>整数线性规划</h3><h4 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h4><p>n 项任务、对应 n 个人承担，应指派哪个人完成哪项任务，使完成效率最高</p><p><strong>最大匹配：</strong>边数最大的匹配</p><p><strong>最优匹配：</strong>带权最大匹配，是指带有权值边的二分图中，求一个匹配使得匹配边上的权值和最大</p><p><strong>例题：</strong></p><p>有一个中文说明书，需要翻译成 英 、日、德、俄四种文字，分别记为 A、B、C、D，现有 甲乙丙丁 四个人，他们将中文说明书翻译成不同的语言所需的时间不同，问应该如何决定该派哪个人去翻译哪种语言，使所需总的时间最少。</p><p><img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308104800870.png" alt="指派问题"></p><p><strong>题解：</strong></p><ul><li>引入变量 $x_{ij}$ , 表示是否安排第 $i$ 个人完成第 $j$ 项翻译工作，为 0 表示不安排第 $i$ 人完成 $j$ 项翻译工作，为 1 表示安排第 $i$ 人完成第 $j$ 项翻译工作。</li><li>目标函数：总时间最小, 表达式为：</li><li>$minZ = 6 x_{11} + 7 x_{12} +11 x_{13} + 2 x_{14} + 4 x_{21} + 5 x_{22} + 9 x_{23} + 8 x_{24} + 3 x_{31} + 1 x{32} + 10 x_{33} + 4 x_{34} + 5 x_{41} + 9 x_{42} + 8 x_{43} + 2 x{44}$</li><li>约束条件：每个人只能完成一项任务，每项任务只能由一个人来完成<ul><li>例如对于甲来说： $x_{11} + x_{12} + x_{13} + x_{14} = 1$</li><li>例如对于A来说：$x_{11} + x_{21} + x_{31} + x_{41} = 1$</li></ul></li></ul><p><strong>指派任务的模型：</strong></p><p>假设 n 个人恰好做 n 项工作，第 $i$ 个人做第 $j$ 项任务的效率为 $c_{ij} \ge 0$ ，应指派哪些人完成哪任务，使完成效率最高。</p><ul><li><p>决策变量：$x_{ij}$</p></li><li><p>目标函数：$ minZ = \sum\limits_{i}\sum\limits_{j} c_{ij} x_{ij} $</p></li><li><p>约束条件：</p><ul><li>$\sum\limits_{i} x_{ij} = 1, j = 1,2,…,n$</li><li>$\sum\limits_{j} x_{ij} = 1, i = 1,2,…,n$</li><li>$x_{ij} = 1 或 0$</li></ul></li></ul><p><strong>匈牙利算法：</strong></p><p>算法条件：</p><ul><li>目标函数求最小值</li><li>人数和任务数相等</li><li>效率非负</li></ul><p>步骤：</p><ul><li>系数矩阵初等行列变换，使各行各列都出现 0 元素（每行每列都减去该行该列最小的元素）</li></ul><p><img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308105841589.png" alt="image-20230308105841589"></p><ul><li><p>试指派寻最优解</p><ul><li><p>找只有一个 0 元素的行，给这个 0 元素画圈，同时划去该列其他的 0 元素</p><p> <img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308112029247.png" alt="image-20230308112029247"></p></li><li><p>找只有一个 0 元素的列，给这个 0 元素画圈，同时划去该行其他的 0 元素</p><p><img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308112136247.png" alt="image-20230308112136247"></p></li><li><p><strong>注意</strong>：被划去的 0 元素不被当作 0 元素看待</p></li><li><p>若还存在没有标记的 0 元素，且找不到独立 0 元素的行（列），从剩余 0 元素最少的行（列）开始，比较这行 0 元素所在列中 0 元素的数目，选择 0 元素最少的那列的这个 0 元素画圈，同时划去该行该列其余的 0 元素。</p><p><img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308113003009.png" alt="image-20230308113003009"></p></li><li><p>如果圈出的 0 元素小于 n 个，那么下一步打勾画直线，增加 0 元素</p><ul><li><p>找到 <strong>没有画圈</strong> 的行并对这行打勾</p></li><li><p>打勾行含 <strong>被划去 0 元素</strong> 的列打勾</p></li><li><p>打勾列含 <strong>画圈 0 元素</strong> 的行打勾</p></li><li><p>依次类推，直到找不出打勾的行或列</p><p><img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308113801134.png" alt="image-20230308113801134"></p></li></ul><p>然后画直线：</p><ul><li>未打勾的行画横线，打勾的列画竖线</li></ul></li></ul></li></ul><p>​  <img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308113831267.png" alt="image-20230308113831267"></p><ul><li><p>增加 0 元素</p><ul><li>找到没有被直线覆盖的<strong>最小元素</strong></li><li>打勾行减去该最小的元素，打勾列加上该最小的元素</li></ul><p><img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308114038134.png" alt="image-20230308114038134"></p></li><li><p>重复上面的步骤，直到在试指派中找到 n 个不同行不同列的 0 元素</p><p><img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308114446797.png" alt="image-20230308114446797"></p></li></ul><p><strong>python 中实现匈牙利算法</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>optimize <span class="token keyword">import</span> linear_sum_assignment<span class="token comment" spellcheck="true"># 构造二分图的代价矩阵</span>cost_matrix <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用 linear_sum_assignment 函数求解最大匹配问题</span><span class="token comment" spellcheck="true"># 该函数参数为：代价矩阵，以及是否求最大值</span><span class="token comment" spellcheck="true"># 函数输出为两个一维数组，表示匹配结果</span>row_ind<span class="token punctuation">,</span> col_ind <span class="token operator">=</span> linear_sum_assignment<span class="token punctuation">(</span>cost_matrix<span class="token punctuation">,</span> maximize<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出最大匹配</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>row_ind<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"左部第{i}个顶点和右部第{col_ind[i]}个顶点匹配"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>linear_sum_assignment 方法是用来求解<strong>最小加权匹配问题</strong>的，为了求二分图最大匹配的问题可以将二分图边权取反</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>optimize <span class="token keyword">import</span> linear_sum_assignment<span class="token comment" spellcheck="true"># 构建二分图邻接矩阵</span>graph <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用 linear_sum_assignment 求解最大匹配</span>row_ind<span class="token punctuation">,</span> col_ind <span class="token operator">=</span> linear_sum_assignment<span class="token punctuation">(</span><span class="token operator">-</span>graph<span class="token punctuation">)</span>matching <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>row_ind<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> col_ind<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>row_ind<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> graph<span class="token punctuation">[</span>row_ind<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> col_ind<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 输出匹配结果</span><span class="token keyword">print</span><span class="token punctuation">(</span>matching<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用下面的方法求解二分图最大匹配问题（可以有多少对）：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> match<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 匹配数组</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// x 是否能找到匹配的</span>bool <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 遍历 x 可以匹配到的点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 这个点没有被考虑过，那就考虑是否可以和它进行匹配</span>            st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 标记为考虑过</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> <span class="token function">find</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 判断是否可以进行匹配，如果 j 这个点没有与之匹配的点，或者j已经匹配了某个点，但是那个点可以换个点进行匹配</span>                match<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 那么 x 找到了匹配的点，并返回 true</span>                <span class="token keyword">return</span> true<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 存取的匹配数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> false<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// i 能找到匹配的</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分支定界法"><a href="#分支定界法" class="headerlink" title="分支定界法"></a>分支定界法</h4><p><img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308161323206.png" alt="image-20230308161323206"></p><p>上界对应的为线性规划问题 B 的目标函数的最大值</p><p>下界是我们求得到的最大整数解</p><p>然后不断缩小上界，增大下界，直到求出 $Z^{*}$</p><p><strong>步骤：</strong></p><ol><li>初始定界：求解线性规划问题 B 的最优解，并将其目标函数值作为 $Z^{<em>}$ 的初始上界；求解 A 的一个整数解，将目标函数值作为 $Z^{</em>}$</li></ol><p>的初始下界。</p><ol start="2"><li>分支：选择 B 最优解中不满足整数条件的变量，添加约束将B 分为两个子问题 $B_{1}$ 和 $B_{2}$ ，不考虑整数约束求解 $B_{1}$ 和 $B_{2}$ 的最优解。</li><li>定界：比较各个分支的解，将最优目标函数值的最大值作为新的上界；将各个分支满足整数条件的解中最大者作为新的下界。</li><li>剪支：比较各个分支的解<ul><li>若小于新的下界，剪支</li><li>若无可行解，剪支</li><li>若大于新的下界，重复步骤 二、三、四</li></ul></li></ol><p><strong>例题：</strong></p><p>  <img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308162752656.png" alt="image-20230308162752656"></p><ol><li>初始定界</li></ol><p>  <img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308162951636.png" alt="image-20230308162951636"></p><p>$Z^{<em>}$ 的初始上下界：$0 \le Z^{</em>} \le 356$ ，下界只要取一个满足条件的 整数解就行，上界是该问题的线性规划的最优解</p><ol start="2"><li><p>分支和定界</p><ul><li><p>基于非整数变量的解分支，基于 $x = 4.81$ , 对线性规划问题 B 增加两个约束：</p><p>​$x_{1} \le 4, x_{1} \ge 5$ </p><p>将线性规划问题 B 分为两个子问题 $B_{1}$ 和 $B_{2}$</p></li><li><p>分别求解子问题 $B_{1}$ 和 $B_{2}$ 的最优解</p><p>$B_{1}$ 的最优解：$x_{1}=4,  x_{2}=2.1,  Z_{1} = 349$ </p><p>$B_{2}$ 的最优解：$x_{1} = 5,  x_{2}=1.57,  Z_{2} = 341$ </p><p>  <img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308164943373.png" alt="image-20230308164943373"></p></li><li><p>定界：$ 0 \le Z_{*} \le 349$</p></li><li><p>将 $B_{1}$ 继续分支，$x_{2} \le 2,  x_{2}\ge 3$  , 分为 $B_{3},  B_{4}$ </p><p>$B_{3}$ 的最优解：$x_{1} = 4, x_{2} = 2, Z_{3} = 340$</p><p>$B_{4}$ 的最优解：$x_{1} = 1.43, x_{2} = 3, Z_{4} = 327$</p></li><li><p>从 340 、327 、341(上一层分支) 中选择最优解作为新的上界，并且此时已经有 $B_{3}$ 问题的整数解，将它作为下界</p><p>$340 \le Z_{*} \le 341$ ， 此时 $B_{4}$ 对应的解可以剪支（因为它的解小于 340，无需再分支）</p></li><li><p>再对 $B_{2}$ 进行分支，$x_{2} \le 1, x_{2} \ge 2$ , 将线性规划问题 $B_{2}$ 分为两个子问题 $B_{5}$ 和 $B_{6}$ (无可行解，剪支)，只需求解 $B_{5}$ 的最优解</p><p>$B_{5}$ 的最优解：$x_{1} = 5.44, x_{2} = 1, Z_{5} = 308$ ，小于 341，剪支。</p><p>  <img src="/images/%E6%95%B4%E6%95%B0%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20230308170446031.png" alt="image-20230308170446031"></p><p><strong>得出结论：</strong> 问题 $B_{3}$ 的最优解为该整数规划问题的最优解 $ x_{1} = 4, x_{2} = 2, Z_{*} = 340$</p></li></ul></li></ol><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 运筹学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运筹学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈、单调队列</title>
      <link href="/2023/03/03/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/03/%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="单调栈、单调队列"><a href="#单调栈、单调队列" class="headerlink" title="单调栈、单调队列"></a>单调栈、单调队列</h3><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>应用问题：给定一个序列，找到每一个数左边（右边）第一个比它大（小）的数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> tt<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> x<span class="token punctuation">;</span>        cin <span class="token operator">>></span> x<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tt <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span> tt<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 直到找到比 x 小的元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tt<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        stk<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>题目：</p><ol><li>LeetCode 下一个更大元素 I</li></ol><p>​用一个字典 m 来存储 nums2 每个元素右边的下一个更大元素</p><pre class="line-numbers language-c"><code class="language-c">class Solution <span class="token punctuation">{</span>public<span class="token punctuation">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> m<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stk<span class="token punctuation">;</span>        m<span class="token punctuation">[</span>nums2<span class="token punctuation">[</span>n2<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>n2<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n2<span class="token number">-2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> m<span class="token punctuation">[</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> m<span class="token punctuation">[</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>LeetCode 每日温度</li></ol><p>​栈中存储的是下标</p><pre class="line-numbers language-c"><code class="language-c">class Solution <span class="token punctuation">{</span>public<span class="token punctuation">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> temperatures<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> temperatures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stk<span class="token punctuation">;</span>        res<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token number">-2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> temperatures<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> temperatures<span class="token punctuation">[</span>stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>应用问题：求一个区间内的最值问题。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断队头是否滑出来窗口</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span> hh<span class="token operator">++</span><span class="token punctuation">;</span>             <span class="token keyword">while</span><span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保持队列中的元素是递增的，比 a[i] 大且在 a[i] 左边的值不会是窗口的最小值，因为 a[i] 比他们更小</span>        q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>力扣 239 题</strong></p><p>​给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><pre class="line-numbers language-c"><code class="language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放的是下标，不是元素</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断队头元素是否滑出了窗口</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">></span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 更新队列，保持队列是递减的</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表、双链表、模拟栈、模拟队列</title>
      <link href="/2023/03/02/%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E3%80%81%E6%A8%A1%E6%8B%9F%E6%A0%88%E3%80%81%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/02/%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E3%80%81%E6%A8%A1%E6%8B%9F%E6%A0%88%E3%80%81%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="单链表、双链表、模拟栈、模拟队列"><a href="#单链表、双链表、模拟栈、模拟队列" class="headerlink" title="单链表、双链表、模拟栈、模拟队列"></a>单链表、双链表、模拟栈、模拟队列</h3><p>单链表：邻接表（存储图和树）</p><p>双链表：优化某些问题</p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> head<span class="token punctuation">,</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    head <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将 x 插入到头结点</span><span class="token keyword">void</span> <span class="token function">add_to_head</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">,</span> head <span class="token operator">=</span> idx<span class="token punctuation">,</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将 x 插入到下标是 k 的点后面</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// x 点的指针指向 k 的下一个点</span>    ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// k 的指针指向 x</span>    idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将下标是 k 的点后面的点删掉</span><span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> ne<span class="token punctuation">[</span>ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用链表进行操作</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// l是左指针，r是右指针</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 0 表示左端点，1表示右端点</span>    r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 单链表使用 head, 双链表使用 0,1 两个结点，真实的结点从 2 开始 </span>    idx <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在下标是 k 的点的右边，插入 x</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    r<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    l<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>    l<span class="token punctuation">[</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>    r<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 删除第 k 个点</span><span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    r<span class="token punctuation">[</span>l<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    l<span class="token punctuation">[</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 双链表的使用    </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 插入</span>stk<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 弹出</span>tt<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断栈是否为空</span><span class="token keyword">if</span><span class="token punctuation">(</span>tt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> False<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不为空</span><span class="token keyword">else</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取栈顶</span>stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 队尾插入元素，队头弹出元素</span><span class="token keyword">int</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 插入</span>q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 弹出</span>hh<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取队头元素, 获取队尾元素</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 判断队列是否为空</span><span class="token keyword">if</span><span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt<span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算合集</title>
      <link href="/2023/03/02/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86/"/>
      <url>/2023/03/02/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul><li><p>n 的二进制表示中第 k 位是几</p><ul><li><p>先把第 k 位移到第一位，n &gt;&gt; k , 右移 k 位</p></li><li><p>看第一位是 0 还是 1， x &amp; 1</p></li></ul></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>k <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>n <span class="token operator">>></span> k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>lowbit 操作，返回 x 的最后一位 1 以及其后的所有 0</p><ul><li>x &amp; -x  =  x &amp; (~x + 1)</li><li>可以用来统计 x 中有多少个 1，每次计算一次 a = x &amp; -x,  再用 x -= a, 循环执行，直到为 0 ，统计循环的次数</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token operator">-</span>x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 统计 1 的个数</span><span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> x <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度运算</title>
      <link href="/2023/03/02/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"/>
      <url>/2023/03/02/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h3><p>当要进行的加减乘除运算数字很大时，使用高精度运算。</p><p>大整数的存储使用数组来存储数的每一位。</p><h4 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h4><p>代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e6</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// A + B</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> B<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> C<span class="token punctuation">;</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> i <span class="token operator">&lt;</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> t <span class="token operator">+</span><span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> t <span class="token operator">+</span><span class="token operator">=</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 进位</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> A<span class="token punctuation">,</span> B<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 存储大整数</span>    cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> A<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span> B<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> C <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>C<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h4><pre class="line-numbers language-c"><code class="language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sub</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> B<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> C<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        t <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> t<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 减去前面进位的</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> t <span class="token operator">-</span><span class="token operator">=</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 因为可能需要前面一位借一位</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> C<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> C<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可能会算出前导 0 的情况</span>    <span class="token keyword">return</span> C<span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">cmp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> B<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// cmp 比较 A,B的大小</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> C <span class="token operator">=</span> <span class="token function">sub</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>C<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">auto</span> C <span class="token operator">=</span> <span class="token function">sub</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>C<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h4><p>A x b,  A很大，b相对较小</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>using namespace std<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mul</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> C<span class="token punctuation">;</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> t<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> t <span class="token operator">+</span><span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">;</span>        C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> C<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> A<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 存储大整数</span>    cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> A<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> C <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>C<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">div</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// r 余数</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> C<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 商</span>    r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 从最高位开始 </span>        r <span class="token operator">=</span> r <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>r<span class="token operator">/</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        r <span class="token operator">%</span><span class="token operator">=</span> b<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 上一轮的余数</span>    <span class="token punctuation">}</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> C<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> C<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> C<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> C<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> A<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 存储大整数</span>    cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> A<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r<span class="token punctuation">;</span>    <span class="token keyword">auto</span> C <span class="token operator">=</span> <span class="token function">div</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> b<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>C<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索</title>
      <link href="/2023/02/28/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
      <url>/2023/02/28/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>二分搜索分为：整数二分和实数二分</p><h4 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h4><ol><li>基本的二分搜索</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">binarySearch1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;=</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">>=</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>寻找左侧边界的二分搜索</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">left_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 注意</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 也可以将 while 区间写成闭区间</span><span class="token keyword">int</span> <span class="token function">left_bound1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 注意</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>寻找右侧边界的二分搜索</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">right_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 或者写成闭区间</span><span class="token keyword">int</span> <span class="token function">right_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h4><p>求一个数的平方根</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    cin <span class="token operator">>></span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">></span> <span class="token number">1e-6</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">double</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token operator">*</span>mid <span class="token operator">>=</span> x<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"%lf\n"</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/02/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>算法模板：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">>=</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">tmp</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例题：Leetcode 剑指 Offer 51 数组中的逆序对</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序每一轮排序都会将一个数归位，即可知道该值是序列中的第几个，而且该值左边的数都小于它，右边的数都大于它。</p><p>算法模板：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">>=</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> l<span class="token punctuation">,</span> high <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> pivot <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span> high<span class="token operator">--</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> pivot <span class="token operator">>=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span> low<span class="token operator">++</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例题：Leetcode 215  数组中的第 k 个最大元素</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树、二分图</title>
      <link href="/2023/02/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E3%80%81%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
      <url>/2023/02/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E3%80%81%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>一般是无向图的最小生成树</p><ol><li>Prim 算法<ol><li>朴素版 Prim ，时间复杂度为 O($n^{2}$) , 稠密图</li><li>堆优化 Prim ，时间复杂度为 O(mlogn) ，稀疏图, 不常用，直接用 Kruskal 算法</li></ol></li><li>Kruskal算法</li></ol><p>​  时间复杂度：O(mlogm)</p><p>稠密图：朴素版 Prim，稀疏图：Kruskal 算法</p><p>Acwing 858 - Prim 算法求最小生成树</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> g<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 最小生成树中，所有边的长度之和</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                t <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">==</span> INF<span class="token punctuation">)</span> <span class="token keyword">return</span> INF<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 说明这是不连通的</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> res <span class="token operator">+</span><span class="token operator">=</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果不是第一个点，则将边加起来</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更新 j 这个点到集合中的距离</span>        <span class="token punctuation">}</span>         st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        g<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token operator">=</span> g<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> INF<span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Kruskal 算法</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">200010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 并查集里面的数组</span><span class="token keyword">struct</span> Edge<span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>w<span class="token punctuation">;</span>    bool opreator<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Edge <span class="token operator">&amp;</span>W<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> w <span class="token operator">&lt;</span> W<span class="token punctuation">.</span>w<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>edges<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span>x<span class="token punctuation">)</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>w<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span>edges <span class="token operator">+</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 初始化并查集</span>    <span class="token comment" spellcheck="true">// 从小到大枚举所有的边</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">,</span> w <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>            p<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 让 a, b 在一个集合中，即在一个连通块内</span>            res <span class="token operator">+</span><span class="token operator">=</span> w<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// res 是最小生成树中边的和</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 已有的边数</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 最小生成树至少要有 n-1 条边</span>    <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h4><p>当且仅当图中不含奇数环那么为二分图，二分图将图中的点分为两个集合，集合内的点不存在边相连。</p><ol><li>染色法</li></ol><p>Acwing 860 - 染色法判定二分图</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">200010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> color<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    color<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>color<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token number">3</span><span class="token operator">-</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>color<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>c<span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 这可以看作是出口</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无向边要加两次</span>    <span class="token punctuation">}</span>    bool flag <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>color<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// color[i] 没染过色，那么为 0</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// dfs 返回 false, 则染色失败</span>                flag <span class="token operator">=</span> false<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Yes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>匈牙利算法</li></ol><p>时间复杂度：最坏时间复杂度 O(mn)，实际时间复杂度会远小于 O(mn)</p><p>Acwing 861 - 二分图的最大匹配</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> match<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 匹配数组</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// x 是否能找到匹配的</span>bool <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 遍历 x 可以匹配到的点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 这个点没有被考虑过，那就考虑是否可以和它进行匹配</span>            st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 标记为考虑过</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> <span class="token function">find</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 判断是否可以进行匹配，如果 j 这个点没有与之匹配的点，或者j已经匹配了某个点，但是那个点可以换个点进行匹配</span>                match<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 那么 x 找到了匹配的点，并返回 true</span>                <span class="token keyword">return</span> true<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 存取的匹配数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> false<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> st<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// i 能找到匹配的</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路算法</title>
      <link href="/2023/02/12/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/12/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h3><ol><li><p>最短路分为：</p><ul><li>单源最短路：一个点到其他点的最短路问题。</li><li>多源汇最短路：不止一个起点和终点</li></ul></li><li><p>单源最短路分为：</p><p>n 表示点的数量， m 表示边的数量，m 和 n^2 一个级别，就是稠密图，m 和 n 一个级别就是稀疏图 </p><ul><li>所有边权都是正数<ul><li>Dijkstra 算法要求边权为正数，因此如果存在自环，最短路和这个自环无关</li><li>朴素 Dijkstra 算法，时间复杂度 O(n^2)，和边数没有关系，稠密图可以使用朴素的算法 </li><li>堆优化版的 Dijkstra 算法，时间复杂度 O(mlogn)，因为稠密图的 m 和 n^2 差不多一个级别，因此稠密图不推荐使用堆优化的版本</li></ul></li><li>存在负权边<ul><li>Bellman-Ford 算法, 时间复杂度 O(mn)</li><li>SPFA 算法，平均时间复杂度 O(m)，最坏 O(mn)，效率比 Bellman-Ford 高</li></ul></li></ul></li><li><p>多源汇最短路</p><ul><li>Folyd 算法，时间复杂度 O(n^3)</li></ul></li></ol><p>无向图和有向图没有区别，在计算最短路时，无向图就是每条边存储两次的有向图，a -&gt; b，b -&gt; a .</p><ol start="4"><li>代码</li></ol><ul><li><p>朴素Dijkstra，适用于稠密图，因此用邻接矩阵来存储, Acwing 849题，Dijkstra求最短路 I</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> g<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 图的邻接矩阵</span><span class="token keyword">int</span> dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 起点到所有点的最短路径</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// st 表示该点是否已经找到最短路径了</span><span class="token keyword">int</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    dist<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 找到最小值 t, 点的编号从 1 开始</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                t <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 这个点的最短路找到</span>        <span class="token comment" spellcheck="true">// 更新其他点的最短路距离</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> g<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x3f</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 0x3f 是 0x3f3f3f, 用于表示无穷大</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        g<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 如果存在重边，那么只取最小的那条边 </span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>堆优化版 Dijkstra 算法，优化上面找最小值的过程，适合稀疏图</p></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> PII<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存储当前距离和编号</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 起点到所有点的最短路径</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// st 表示该点是否已经找到最短路径了</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    dist<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span>PII<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>PII<span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>PII<span class="token operator">>></span> heap<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 小根堆</span>    heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">auto</span> t <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 找到当前最小值的点</span>        heap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ver <span class="token operator">=</span> t<span class="token punctuation">.</span>second<span class="token punctuation">,</span> distance <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// ver 表示该点的编号，distance 表示该点到 1 号点的最短距离</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>ver<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 这个点的最短距离已经找到了就跳过</span>        st<span class="token punctuation">[</span>ver<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// ver 这个点的最短路径已经找到</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>ver<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 找这个点所有的邻边</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> distance <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 更新 dist[j] 的最短距离</span>                dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> distance <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                heap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆中可能会剩余一些元素，这些元素更新不了dist，因为假设有重边的情况下，堆会取出小的那条边，当所有点都找完最小路径之后，堆中会剩余值比较大的边，这些边更新不了用较小的边更新的dist数组</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x3f3f3f</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 0x3f 是 0x3f3f3f, 用于表示无穷大</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span>       <span class="token punctuation">}</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果图中存在负权回路，那么不存在最短路</p><h4 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h4><p>可以用来求图中有没有负环，但是一般不这么做</p><p>Acwing 853 有边数限制的最短路：</p><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。请从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible ，图中可能存在负权回路</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">10010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> k<span class="token punctuation">;</span><span class="token keyword">int</span> dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> backup<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span># 边结构体<span class="token keyword">struct</span> Edge<span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span><span class="token punctuation">}</span>edges<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">bellman_ford</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f3f3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property"># k 表示不超过 k 条边的最短路径的距离</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>backup<span class="token punctuation">,</span> dist<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dist<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 用上一次的 dist 来更新下一次的 dist</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">,</span> w <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            dist<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> backup<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 更新距离</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0x3f3f3f</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 不存在 1 - n 的路径</span>    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>w<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">bellman_ford</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SPFA算法-（负权图最好用）"><a href="#SPFA算法-（负权图最好用）" class="headerlink" title="SPFA算法 （负权图最好用）"></a>SPFA算法 （负权图最好用）</h4><p>Acwing 中 spfa求最短路问题</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> PII<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存储当前距离和编号</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 起点到所有点的最短路径</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// st 表示该点是否已经找到最短路径了</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token number">0x3f</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    dist<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    st<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// st 表示该点是不是已经在队列中</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 取出该点后，要置为 false</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 j 不在队列中，那么入队</span>                    st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x3f3f3f</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dist<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 0x3f 是 0x3f3f3f, 用于表示无穷大</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span>       <span class="token punctuation">}</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断负环：可以维护一个 cnt 数组，cnt[x] 表示 1 到 x 这个点最短路径所包含的边数。如果 cnt[x] &gt;= n，那就说明有 n+1 个点，说明这个最短路径有负环。Acwing 852 - spfa 判断负环</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> PII<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存储当前距离和编号</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 起点到所有点的最短路径</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// st 表示该点是否已经找到最短路径了</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// memset(dist, 0x3f, sizeof dist);    // 不需要初始化</span>    <span class="token comment" spellcheck="true">// dist[1] = 0;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将所有点都要放入到队列中，因为可能从 1 开始的路径不经过环</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 取出该点后，要置为 false</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> true<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 j 不在队列中，那么入队</span>                    st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>       <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 0x3f 是 0x3f3f3f, 用于表示无穷大</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span>       <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Yes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h4><p>Floyd 算法：时间复杂度 O($n^{3}$)，可以处理负权边，但不能有负权回路</p><p>Acwing 854 - Floyd 求最短路</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">210</span><span class="token punctuation">,</span> INF <span class="token operator">=</span> <span class="token number">1e9</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>Q<span class="token punctuation">;</span><span class="token keyword">int</span> d<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">floyd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>j<span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> INF<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">floyd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>Q<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">></span> INF<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树—图的存储—深度优先遍历—广度优先遍历—拓扑排序</title>
      <link href="/2023/02/12/%E6%A0%91%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2023/02/12/%E6%A0%91%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="树和图的存储-、深度优先搜索、广度优先搜索、拓扑序列"><a href="#树和图的存储-、深度优先搜索、广度优先搜索、拓扑序列" class="headerlink" title="树和图的存储 、深度优先搜索、广度优先搜索、拓扑序列"></a>树和图的存储 、深度优先搜索、广度优先搜索、拓扑序列</h3><ol><li><p>树是特殊的图（无环联通图）</p></li><li><p>图分为：有向图、无向图（每条边要建立两次，看成是一种特殊的有向图），只需考虑有向图如何存储</p></li><li><p>有向图存储方式：</p><ul><li>邻接矩阵：g[a][b] 存储 a -&gt; b 的边，适用于稠密图，不能存取重边，用的比较少。</li><li>邻接表：每个点都有一个单链表，单链表存储该点的邻点。</li></ul></li><li><p>代码</p></li></ol><ul><li>邻接表、深度优先搜索</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">,</span> M <span class="token operator">=</span> N<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span>bool st<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加一条 a->b 的边</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 深度优先遍历</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">{</span>    st<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//标记被访问过</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 获取这个点的邻点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 将 h 数组都初始化为 -1</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>邻接表、广度优先搜索</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> h<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">int</span> d<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">,</span> ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 所有的距离都初始化为 -1</span>    d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>hh<span class="token operator">&lt;=</span>tt<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">[</span>hh<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 获取队头元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 还未找到 j 这个点到 1 的最短距离</span>                d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 更新 j 这个点的最短距离</span>                q<span class="token punctuation">[</span><span class="token operator">++</span>tt<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 并把 j 加入到队列中</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>拓扑序列</li></ol><ul><li>定义：拓扑序列中一个点之前所有的点在图中都在该点前面，有环图不存在拓扑序列</li><li>入度、出度：一个点的入度是指有多少条边指向自己，一个点的出度表示有多少条边从自己出去</li><li>拓扑序列中所有入度为 0 的点都可以作为拓扑序列的起点</li><li>代码：</li></ul><pre class="line-numbers language-C"><code class="language-C">const int N = 100010;int n,m;int h[N], e[N], ne[N], idx;   // 图的存储int q[N], d[N];               // 队列 和 每个点的入度数组void add(int a,int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx++;}// 拓扑序列bool topsort(){    int hh=0, tt = -1;    // 将所有入度为 0 的点加入队列    for(int i = 1;i <= n;i++){        if(!d[i])            q[++tt] = i;    }    while(hh <= tt){        int t = q[hh++];   // 取队头元素        for(int i = h[t];i!=-1;i = ne[i]){            int j = e[i];            d[j]--;     // 将 j 的入度减 1            if(d[j]==0) q[++tt] = j;  // 当 j 的入度减为 0 了，就可以将 j 入队了        }    }    return tt == n - 1;    // 表示这个图所有点都进入过队列了，有拓扑序列，否则不存在拓扑序列}int main(){    cin >> n >> m;    memset(h,-1,sizeof h);    for(int i=0;i<m;i++){        int a, b;        cin >> a >> b;        add(a,b);        d[b]++;      // 统计所有点的入队    }    if(topsort()){        for(int i = 0;i < n;i++) printf("%d", q[i]);        puts(" ");    }else puts("-1");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2022/05/15/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2022/05/15/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">slidingWindow</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span><span class="token punctuation">{</span>    HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> need <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">;</span>    HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 先将 need 填完，need是固定的</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span>t<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        need<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>need<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对窗口window进行更新</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>windows need shrink<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> d <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 对窗口进行更新</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>最小覆盖子串（76）</li></ol><p>​<a href="https://leetcode.cn/problems/minimum-window-substring/">https://leetcode.cn/problems/minimum-window-substring/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">minWindow</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> need <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span>t<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            need<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>need<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">int</span> valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加入到窗口中</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 如果满足need，valid++</span>                    valid<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>valid<span class="token operator">==</span>need<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 收缩</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">&lt;</span>len<span class="token punctuation">)</span><span class="token punctuation">{</span>                    start <span class="token operator">=</span> left<span class="token punctuation">;</span>                    len <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">char</span> d <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        valid<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> len<span class="token operator">==</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token operator">?</span><span class="token string">""</span><span class="token operator">:</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>start<span class="token operator">+</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>字符串排列（567）</li></ol><p>​<a href="https://leetcode.cn/problems/permutation-in-string/">https://leetcode.cn/problems/permutation-in-string/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkInclusion</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> need <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span>s1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            need<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>need<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">==</span>need<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    valid<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">></span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>valid<span class="token operator">==</span>need<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">char</span> d <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">==</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        valid<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>找所有字母异位词（438）</li></ol><p>​<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String p<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> need <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token operator">:</span>p<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            need<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>need<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                          valid<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>valid<span class="token operator">==</span>need<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">char</span> d <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>need<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        valid<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>无重复字符串的最长字串（3）</li></ol><p>​<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>            window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当已存在 c 字符时</span>                <span class="token keyword">char</span> d <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 当没有重复数据时，right都是经过 + 1的，所以不需要 right-left + 1</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分数组</title>
      <link href="/2022/05/15/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
      <url>/2022/05/15/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><h3 id="适用问题"><a href="#适用问题" class="headerlink" title="适用问题"></a>适用问题</h3><p>​频繁地对原始数组的某个区间的元素进行增减。</p><h3 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 构造差分数组</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> diff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过差分数组修改原始数组</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> val<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        diff<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回修改后的原始数组</span><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li><p>区间加法（370）</p><p>假设有一个长度为 n 的数组，初始情况下所有的数字均为0，你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组[startindex, endindex, inc]，目的是修改原始数组的 [startindex，endindex] 的值。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getModifiedArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> updatesets<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> diff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> update<span class="token operator">:</span>updates<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> update<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> val <span class="token operator">=</span> update<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        diff<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+=</span> val<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            diff<span class="token punctuation">[</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-=</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>航班预定统计（1109）</p></li></ol><p>​<a href="https://leetcode.cn/problems/corporate-flight-bookings/">https://leetcode.cn/problems/corporate-flight-bookings/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">corpFlightBookings</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bookings<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> diff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> book<span class="token operator">:</span>bookings<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> book<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> end <span class="token operator">=</span> book<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> val <span class="token operator">=</span> book<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            diff<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">+=</span> val<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>end<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>                diff<span class="token punctuation">[</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-=</span>val<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>         res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​3. 拼车（1094）</p><p>​<a href="https://leetcode.cn/problems/car-pooling/">https://leetcode.cn/problems/car-pooling/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">carPooling</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> trips<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> diff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> trip<span class="token operator">:</span>trips<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> trip<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> end <span class="token operator">=</span> trip<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 因为trip[2]人已经下车了</span>            <span class="token keyword">int</span> val <span class="token operator">=</span> trip<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            diff<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">+=</span> val<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                diff<span class="token punctuation">[</span>end<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> val<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>m<span class="token punctuation">)</span><span class="token punctuation">{</span>                m <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> m<span class="token operator">></span>capacity<span class="token operator">?</span><span class="token boolean">false</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和数组</title>
      <link href="/2022/05/15/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/"/>
      <url>/2022/05/15/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和数组"><a href="#前缀和数组" class="headerlink" title="前缀和数组"></a>前缀和数组</h1><h3 id="适用问题"><a href="#适用问题" class="headerlink" title="适用问题"></a>适用问题</h3><p>原始数组不会被修改的情况下，频繁的查询某个区间的累加和。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>区域和检索 - 数组不可变（303）</li></ol><p>​<a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">NumArray</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preSum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NumArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        preSum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>preSum<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 查询闭区间[left,right]的累加和 */</span>    Public <span class="token keyword">int</span> <span class="token function">sumRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> preSum<span class="token punctuation">[</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> preSum<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>二维区域和检索 - 矩阵不变性（304）</li></ol><p>​<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">https://leetcode.cn/problems/range-sum-query-2d-immutable/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">NumMatrix</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> perfix<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NumMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        perfix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>matrix<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>matrix<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                perfix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> perfix<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> perfix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> perfix<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> matrix<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumRegion</span><span class="token punctuation">(</span><span class="token keyword">int</span> row1<span class="token punctuation">,</span> <span class="token keyword">int</span> col1<span class="token punctuation">,</span> <span class="token keyword">int</span> row2<span class="token punctuation">,</span> <span class="token keyword">int</span> col2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> perfix<span class="token punctuation">[</span>row2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> perfix<span class="token punctuation">[</span>row1<span class="token punctuation">]</span><span class="token punctuation">[</span>col2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> perfix<span class="token punctuation">[</span>row2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col1<span class="token punctuation">]</span> <span class="token operator">+</span> perfix<span class="token punctuation">[</span>row1<span class="token punctuation">]</span><span class="token punctuation">[</span>col1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>和为 k 的子数组（560）</li></ol><p>​<a href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> perSum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        perSum<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>sum_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum_i <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum_j <span class="token operator">=</span> sum_i<span class="token operator">-</span>k<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>perSum<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>sum_j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res <span class="token operator">+=</span> perSum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sum_j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            perSum<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>sum_i<span class="token punctuation">,</span>perSum<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>sum_i<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征工程之特征表达</title>
      <link href="/2022/03/28/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E5%BE%81%E8%A1%A8%E8%BE%BE/"/>
      <url>/2022/03/28/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E5%BE%81%E8%A1%A8%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="特征工程之特征表达"><a href="#特征工程之特征表达" class="headerlink" title="特征工程之特征表达"></a>特征工程之特征表达</h1><h2 id="1-缺失值处理"><a href="#1-缺失值处理" class="headerlink" title="1. 缺失值处理"></a>1. 缺失值处理</h2><p>数据有缺失值是很常见的，但是在训练模型时，数据要求不能有缺失值，处理方法如下：</p><ol><li>针对连续值，可以取所有样本的平均值来填充，或者取所有样本的中位数来填充</li><li>如果是离散值，可以取样本中出现最频繁的特征值来填充</li></ol><h2 id="2-特殊的特征处理"><a href="#2-特殊的特征处理" class="headerlink" title="2. 特殊的特征处理"></a>2. 特殊的特征处理</h2><p>有些特征的取值比较特殊，例如日期时间，该如何表达呢？</p><ol><li>时间差值法，计算所有样本时间到未来某一个时间的数值差距，这个差距是 UTC 的时间差，从而将时间特征转化为连续值</li><li>根据时间所在的年、月、日、星期几，将一个时间特征转化为多个离散的特征，这种方法在分析具有明显时间趋势的问题上比较好用</li><li>根据时间的新旧得到一个权重值，例如，三个月前是某个权重，最近一个月是一个权重，最近一周又是另一个权重</li></ol><p>对地理特征的处理</p><ol><li>离散值，可以将一个位置处理成多个特征，比如，城市特征，区县特征，接到特征等</li><li>连续值，但如果我们需要判断用户分布的区域，则一般处理成连续值会比较好，可以转化为地里的经度和纬度</li></ol><h2 id="3-离散特征连续化处理"><a href="#3-离散特征连续化处理" class="headerlink" title="3. 离散特征连续化处理"></a>3. 离散特征连续化处理</h2><p>有很多机器学习算法只能处理连续特征，不能处理离散特征，比如线性回归，逻辑回归等。</p><ol><li>独热编码：这是最常见的处理方法，比如某特征的取值是高、中、低，那么我们就可以创建三个取值为 0 或者 1 的特征，将高编码为 1, 0, 0 这样三个特征，中编码为 0，1，0 这三个特征，低编码为 0，0，1 这三个特征，也就是说之前的一个特征被我们转化为三个特征，sklearn 中的 OneHotEncoder 可以进行独热编码。</li><li>特征嵌入 embedding ，这个方法一般用于深度学习中，比如对于用户 ID 这个特征，如果使用独热编码，则维度会爆炸，如果使用特征嵌入维度就会低很多，对于每个要嵌入的特征，我们会有一个嵌入矩阵，这个矩阵的行很大，对应该特征的数目，比如用户 ID，如果有 100 万个，那么嵌入的特征矩阵的行就是100万个，但是列一般比较小，比如取 20，这样这个用户 ID 特征就转化为 20 维，进而参与深度学习模型，在 tensorflow 中，我们可以先随机初始化一个特征嵌入矩阵，对于每个用户，可以用 tf.nn.embedding_lookup找到该用户的特征嵌入向量，特征嵌入矩阵会在反向传播的迭代中优化。</li><li>在自然语言处理中，也可以用 word2vec 将词转换为词向量，进而可以进行一些连续值的处理。</li></ol><h2 id="4-离散特征的离散化处理"><a href="#4-离散特征的离散化处理" class="headerlink" title="4. 离散特征的离散化处理"></a>4. 离散特征的离散化处理</h2><p>离散特征有时候也不能直接使用，需要进行转化</p><ol><li><p>上一节介绍的是独热编码，这一节的方法是 虚拟编码 dummy coding，它和独热编码类似，但是它的特点是，如果该特征有 N 个取值，只需要 N-1 个新的 0 和 1 的特征来代替，而独热编码则会用 N 个新特征来代替，例如 高、中、低，只需要两个特征来代替，00 代表高，10 代表中，01 代表低，一般还是使用独热编码。</p></li><li><p>有的时候可以修改特征，例如 原始特征有 春夏秋冬，可以将其修改为 旺季和淡季这样的二值特征。也可以变成三值特征或四值特征。</p></li><li><p>对于分类问题的输出，一般需要用 sklearn 的 LabelEncoder 将其转化为 $0,1,2\dots$ 这样的类别标签值。</p></li></ol><h2 id="5-连续特征离散化处理"><a href="#5-连续特征离散化处理" class="headerlink" title="5. 连续特征离散化处理"></a>5. 连续特征离散化处理</h2><ol><li>根据阈值进行分组，例如年龄，0-20 分一类，20-40分一类，后面依次类推。</li><li>使用 GBDT 方法，GBDT先将连续值转化为离散值，那么如何转化呢，例如，如果使用样本集中所有的连续值和标签来训练 GBDT，训练出的GBDT有两棵决策树，第一棵决策树有 三个 叶子节点，第二棵决策树有四个叶子节点，一个样本落在第一棵决策树的第二个叶子节点，落在第二棵决策树的第四个叶子节点，那么这个样本的连续值编码为离散值则为 （0，1，0，0，0，0，1）一共七个离散的特征，可以使用 sklearn 中的 GradientBoostingClassifier 的 apply 方法很方便的得到样本的离散化后的特征，然后使用独热编码即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征工程之特征选择</title>
      <link href="/2022/03/27/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/"/>
      <url>/2022/03/27/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="特征工程之特征选择"><a href="#特征工程之特征选择" class="headerlink" title="特征工程之特征选择"></a>特征工程之特征选择</h1><p>在选择特征时，一般特征有两种来源，一是已经整理好的各种特征，这类特征我们要去找适合我们问题的特征，另一类是从这些整理好的特征中去寻找高级特征。</p><h2 id="1-选择合适的特征"><a href="#1-选择合适的特征" class="headerlink" title="1. 选择合适的特征"></a>1. 选择合适的特征</h2><ol><li>寻找专家，向他咨询哪些特征会对预测结果产生影响，不论影响的大小都要选择。</li><li>在降维之前，可以使用特征工程的方法去选择出比较重要的特征，例如，方差选择法。</li></ol><p>​选择特征一般有以下三种方法：</p><ol><li>过滤法：按照特征的发散性或者相关指标对各个特征进行评分，设定评分阈值，选择合适的特征，方差法就是过滤法的一种。</li><li>包装法：根据目标函数，通常是预测效果评分，每次选择部分特征，或者排除部分特征。</li><li>嵌入法：先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据权值的大小来选择特征。</li></ol><h3 id="1-1-过滤法选择特征"><a href="#1-1-过滤法选择特征" class="headerlink" title="1.1 过滤法选择特征"></a>1.1 过滤法选择特征</h3><ol><li><p>方差选择法：计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征，使用 feature_selection 库中的 VarianceThreshold 类</p><p>来选择特征。</p></li><li><p>相关系数法：计算各个特征对目标值的相关系数以及相关系数的 P 值，主要用于输出连续值的监督学习算法中，使用 </p><p>feature_selection 库中的 SelectKBest 结合相关系数来选择特征。</p></li><li><p>卡方检验：可以检验某个特征分步和输出值之间的相关性，使用 feature_selection 库中的 SelectKBest 类结合卡方检验来选择特征。</p></li><li><p>互信息：从信息熵的角度分析各个特征和输出值之间的评分关系，互信息越大，说明该特征和输出值之间的相关性越大，越需要保留，</p><p>使用 feature_selection 库中的 SelectKBest 结合最大信息系数来选择特征。</p></li></ol><h3 id="1-2-包装法选择特征"><a href="#1-2-包装法选择特征" class="headerlink" title="1.2 包装法选择特征"></a>1.2 包装法选择特征</h3><ol><li><p>递归特征消除法</p><p>递归特征消除法使用一个基模型来进行多轮训练，每轮训练后，消除若干权值系数的特征，再基于新的特征集进行下一轮训练。对特征含有权重的预测模型(例如，线性模型对应参数coefficients)，RFE通过<strong>递归减少考察的特征集规模来选择特征</strong>。首先，预测模型在原始特征上训练，每个特征指定一个权重。之后，那些拥有最小绝对值权重的特征被踢出特征集。如此往复递归，直至剩余的特征数量达到所需的特征数量。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> RFE<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression<span class="token comment" spellcheck="true">#递归特征消除法，返回特征选择后的数据</span><span class="token comment" spellcheck="true">#参数estimator为基模型</span><span class="token comment" spellcheck="true">#参数n_features_to_select为选择的特征个数</span>RFE<span class="token punctuation">(</span>estimator<span class="token operator">=</span>LogisticRegression<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n_features_to_select<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>iris<span class="token punctuation">.</span>data<span class="token punctuation">,</span> iris<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="1-3-嵌入法选择特征"><a href="#1-3-嵌入法选择特征" class="headerlink" title="1.3 嵌入法选择特征"></a>1.3 嵌入法选择特征</h3><p>嵌入法也是用机器学习的方法来选择特征，但是它和RFE的区别是它不是通过不停的筛掉特征来进行训练，而是使用的都是特征全集。在sklearn中，使用SelectFromModel函数来选择特征。</p><ol><li>基于惩罚项的特征选择法</li></ol><p>​最常用的是使用L1正则化和L2正则化来选择特征。当正则化系数大到一定程度时，部分特征系数会变成 0 ，当再增大，那么所有特征的系数都会趋于 0 ，但是我们会发现有些特征会先趋于 0 ，把这类特征筛选掉。基模型是逻辑回归模型。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> SelectFromModel <span class="token comment" spellcheck="true">#带L1和L2惩罚项的逻辑回归作为基模型的特征选择</span><span class="token comment" spellcheck="true">#参数threshold为权值系数之差的阈值</span>SelectFromModel<span class="token punctuation">(</span>LR<span class="token punctuation">(</span>threshold<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> C<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>iris<span class="token punctuation">.</span>data<span class="token punctuation">,</span> iris<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>基于树模型的特征选择法</li></ol><p>​树模型中GBDT也可用来作为基模型进行特征选择，使用feature_selection库的SelectFromModel类结合GBDT模型。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> SelectFromModel<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> GradientBoostingClassifier<span class="token comment" spellcheck="true">#GBDT作为基模型的特征选择</span>SelectFromModel<span class="token punctuation">(</span>GradientBoostingClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>iris<span class="token punctuation">.</span>data<span class="token punctuation">,</span> iris<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-寻找高级特征"><a href="#2-寻找高级特征" class="headerlink" title="2 寻找高级特征"></a>2 寻找高级特征</h2><p>可以根据上面选择的初级特征来获得一些二级特征，例如已有 距离 和 时间 两个特征，可以得出 速度这个特征，还可以有三级、四级特征。</p><p>寻找高级特征的方法：</p><ul><li>若干项特征加和： 我们假设你希望根据每日销售额得到一周销售额的特征。你可以将最近的7天的销售额相加得到。</li><li>若干项特征之差： 假设你已经拥有每周销售额以及每月销售额两项特征，可以求一周前一月内的销售额。</li><li>若干项特征乘积： 假设你有商品价格和商品销量的特征，那么就可以得到销售额的特征。</li><li>若干项特征除商： 假设你有每个用户的销售额和购买的商品件数，那么就是得到该用户平均每件商品的销售额。</li></ul><p>当模型的效率得不到进一步提高时，可以考虑寻找高级特征。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bagging与随机森林算法原理</title>
      <link href="/2022/03/26/Bagging%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/26/Bagging%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Bagging与随机森林算法原理"><a href="#Bagging与随机森林算法原理" class="headerlink" title="Bagging与随机森林算法原理"></a>Bagging与随机森林算法原理</h1><p>随机采样：从训练集里面采集固定个数的样本，但是每采集一个样本后，都将样本放回。就是说，之前采集的样本仍有可能继续被采集到，</p><p>Bagging算法一般会随机采集和训练样本数一样的个数的样本。这样得到的采样集和训练集样本的个数相同，但是样本内容不同。</p><p>对于某一个样本，在m个样本里，每次被采集的概率是 $\frac{1}{m}$，不被采集的概率是 $1-\frac{1}{m}$，如果 m 次采样都没有被采集中的概率为$(1-m)^{m}$ </p><p>，当 $m\longrightarrow \infty$ 时，$(1-\frac{1}{m})^{m}\longrightarrow\frac{1}{e}\simeq 0.368$ ，也就是说，在 bagging 每次采样中，训练集中大约有 36.8% 的数据没有被采样集采集。</p><p>bagging 对弱学习器没有限制，这和 Adaboost 一样，但是最常用的一般也是决策树和神经网络。</p><p>bagging 的结合策略也比较简单，对于分类问题，通常使用投票法，得到最多票数的类别或者类别之一为最终的模型输出。对于回归问</p><p>题，通常使用简单平均法，对 $T$ 个弱学习器得到的回归结果进行算术平均得到最终的模型输出。</p><h2 id="1-bagging算法流程"><a href="#1-bagging算法流程" class="headerlink" title="1. bagging算法流程"></a>1. bagging算法流程</h2><p>输入：样本集 $D = {(x_{1},y_{1}),(x_{2},y_2),\dots(x_{m},y_{m})}$，弱学习器算法，弱学习器迭代次数 $T$ </p><p>输出：最终的强分类器 $f(x)$</p><p>（1）对于 $t=1,2\dots,T$</p><p>a）对训练集进行第 $t$ 次采样，共采集 $m$ 次，得到包含 $m$ 个样本的采样集 $D_{t}$</p><p>b）用采样集 $D_{t}$ 训练第 $t$ 个弱学习器 $G_{t}(x)$</p><p>（2）如果是分类算法预测，则 $T$ 个弱学习器投出最多的票数的类别或者类别之一为最终的类别。如果是回归算法，$T$ 个弱学习器得到的回归结果进行算术平均得到的值为最终的模型输出</p><h2 id="2-随机森林算法（RF）"><a href="#2-随机森林算法（RF）" class="headerlink" title="2. 随机森林算法（RF）"></a>2. 随机森林算法（RF）</h2><p>​RF思想仍是Bagging算法，只不过多加了些限制</p><ul><li>RF 使用了 CART 决策树作为弱学习器。</li><li>在决策树的建立上做了改进，对于<strong>普通的决策树</strong>来说，会在所有 n 个样本特征中去选择一个最优的特征来做决策树的左右子树的划分，RF 则是随机选择一部分特征，特征数假设为 $n_{sub}$ ，然后在随机选择的 $n_{sub}$ 个样本特征中，选择一个最优子树来做决策树的左右子树的划分，进一步增强了模型的泛化能力。$n_{sub}$ 越小，模型越健壮，当然此时对于训练集的拟合程度会变差，也就是说 $n_{sub}$ 越小，模型的方差（测试集的误差）会减小，但是偏差（训练集的误差）会增大，我们需要通过交叉验证法调参获取一个合适的 $n_{sub}$ 的值。</li></ul><p>​<strong>RF算法：</strong></p><p>​输入：样本集 $D={(x_{1},y_{1}),(x_{2},y_{2})\dots(x_{m},y_{m})}$，弱分类器的迭代次数 $T$</p><p>​输出：最终的强分类器 $f(x)$ </p><p>​（1）对于 $t=1,2\dots,T$</p><p>​a）对训练集进行第 $t$ 次随机采样，共采集 $m$ 次，得到包含 $m$ 个样本的采样集 $D_{t}$</p><p>​b）用采样集去训练第 $t$ 个决策树模型 $G_{t}(x)$，在训练决策树模型的结点的时候，从样本特征中随机选择一部分样本特征，然后再选择一个最优特征做决策树的左右子树的划分</p><p>​（2）如果是分类预测，则 $T$ 个弱学习器投出最多的票数或最多的票数之一的类别为最终类别，如果是回归算法，则将 $T$ 个弱学习器进行算术平均求得的值作为最终的输出</p><h2 id="3-随机森林小结"><a href="#3-随机森林小结" class="headerlink" title="3. 随机森林小结"></a>3. 随机森林小结</h2><p>对于数据量比较大的情况，RF算法很有用</p><p><strong>RF优点：</strong></p><p>（1）训练可以高度并行化，对于大数据时代的大样本训练速度有优势</p><p>（2）由于可以随机选择决策树结点划分特征，这样在样本特征维度很高的时候，仍可以高效的训练模型</p><p>（3）在训练后，可以给出各个特征对于输出的重要性</p><p>（4）由于是随机采样，训练出的模型方差小，泛化能力强</p><p>（5）相对于 Boosting 系列的 Adaboost 和 GBDT，RF实现比较简单</p><p>（6）对部分特征缺失不敏感</p><p><strong>RF缺点：</strong></p><p>（1）在某些噪音比较大的样本集上，RF 模型容易陷入过拟合</p><p>（2）取值划分比较多的特征容易对 RF 的决策产生更大的影响，从而影响拟合模型的效果</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度提升树(GBDT)算法原理</title>
      <link href="/2022/03/25/%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E6%A0%91%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/25/%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E6%A0%91%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="梯度提升树（GBDT）算法"><a href="#梯度提升树（GBDT）算法" class="headerlink" title="梯度提升树（GBDT）算法"></a>梯度提升树（GBDT）算法</h1><h2 id="1-GBDT概述"><a href="#1-GBDT概述" class="headerlink" title="1. GBDT概述"></a>1. GBDT概述</h2><p>​Adaboost 是利用前一轮弱学习器的误差率来更新训练集的权重，这样一轮轮迭代下去。GBDT也是如此，也是用前向分步算法，但是弱学习器限定为 CART 树，同时迭代的方式也和 Adaboost 算法不同。</p><p>​GBDT 对于前一轮得到的强学习器 $f_{t-1}(x)$，下一轮旨在要学习到一个弱学习器 $h_{t}(x)$ ，让本轮的损失函数 $L(y,f_{t}(x)) = L(y,f_{t-1}(x)+h_{t}(x))$ 最小，也就是说本轮迭代产生的 弱学习器，要让样本的损失函数尽可能的小。</p><p>​<strong>问题：</strong> 损失函数各种各样，残差不好计算，损失函数的拟合不好度量。</p><h2 id="2-GBDT-的负梯度拟合"><a href="#2-GBDT-的负梯度拟合" class="headerlink" title="2. GBDT 的负梯度拟合"></a>2. GBDT 的负梯度拟合</h2><p>第 $t$ 轮，第 $i$ 个样本的损失函数的负梯度表示为：</p><p>$r_{ti} = -[\frac{\partial L(y_{i},f(x_{i}))}{\partial f(x_{i})}]<em>{f(x)=f</em>{t-1}(x)}$ </p><p>$y_{i}$ 是样本的输出值，$f(x)$ 为 $t-1$ 轮学到的强学习器 </p><p>然后利用 $(x_{i},r_{ti}),i=1,2\dots m$ 我们可以拟合一棵 CART 回归树，得到第 $t$ 棵回归树，其对应的叶子节点区域为 $R_{tj},j=1,2\dots J$ , $J$ 为</p><p>叶子结点的个数  </p><p>对每一个叶子结点里的样本，我们求出使损失函数最小，也就是拟合叶子节点最好的输出值 $c_{tj}$ 如下：</p><p>$c_{tj} = argmin_{c}\sum_{x_{i}\in R_{tj}}L(y_{i},f_{t-1}(x)+c)$</p><p>之前在求回归问题时，使损失函数最小的那个值 $c_{tj}$ 是叶子结点里所有样本的平均值（平方差损失函数），现在损失函数普遍化，不一定是</p><p>平方差损失函数</p><p>所以得到本轮的决策树拟合函数为：</p><p>$h_{t}(x) = \sum_{j=1}^{J}c_{tj}I(x\in R_{tj})$</p><p>所以本轮最终得到的强学习器表示为：</p><p>$f_{t}(x) = f_{t-1}(x) + \sum_{j=1}^{J}c_{tj}I(x \in R_{tj})$</p><h2 id="3-GBDT-回归算法"><a href="#3-GBDT-回归算法" class="headerlink" title="3. GBDT 回归算法"></a>3. GBDT 回归算法</h2><p>输入：训练集样本，$T((x_{1},y_{1}),(x_{2},y_{2}),\dots(x_{m},y_{m}))$ ，最大迭代次数 $T$ , 损失函数 $L$ </p><p>输出：强学习器 $f(x)$</p><p>（1）初始化弱学习器</p><p>​$f_{0}(x) = argmin_{c}\sum_{i=1}^{m}L(y_{i},c)$</p><p>（2）迭代轮数 $t=1,2\dots T$，有</p><p>​a) 对样本 $i=1,2,\dots m$ ，计算负梯度</p><p>​$r_{ti} = -[\frac{\partial L(y_{i},f(x_{i}))}{\partial f(x_{i})}]$</p><p>​b) 利用 $(x_{i},r_{ti}), i=1,2\dots m$ ，拟合一棵 CART 回归树，其对应的叶子区域 为 $R_{tj},j=1,2\dots,J$ ，其中 $J$ 为叶子结点个数</p><p>​c) 计算每个叶子结点区域的最佳拟合值</p><p>​$c_{tj} = argmin_{c}\sum_{x_{i}\in R_{tj}}L(y_{i},f_{t-1}(x_{i})+c)$ </p><p>​d) 更新强学习器 </p><p>​$f_{t}(x) = f_{t-1}(x) + \sum_{j=1}^{J}c_{tj}I(x\in R_{tj})$</p><p>​ （3）得到强学习器 $f(x)$ 的表达式</p><p>​$f(x) = f_{T}(x) = f_{0}(x) + \sum_{t=1}^{T}\sum_{j=1}^{J}c_{tj}I(x\in R_{tj})$ </p><h2 id="4-GBDT分类算法"><a href="#4-GBDT分类算法" class="headerlink" title="4. GBDT分类算法"></a>4. GBDT分类算法</h2><p>​GBDT 的分类算法思想上和GBDT回归算法一样，但是分类问题的样本输出是离散值，无法去拟合类别输出的误差。</p><p>解决这个问题，主要有两个方法：</p><ul><li>使用指数损失函数，此时的 GBDT 就是 Adaboost 算法</li><li>利用对数似然函数，使用类别预测的概率值和真实概率值的差来拟合损失，分为 二元分类和多元分类</li></ul><h3 id="4-1-二元-GBDT-分类算法"><a href="#4-1-二元-GBDT-分类算法" class="headerlink" title="4.1 二元 GBDT 分类算法"></a>4.1 二元 GBDT 分类算法</h3><p>​损失函数为：</p><p>​$L(y,f(x)) = log(1+exp(-yf(x)))$</p><p>​其中 $y\in{-1,+1}$，则此时负梯度误差为：</p><p>​$ r_{ti} = -\left[ \frac{\partial L(y,f(x_{i}))}{\partial f(x_{i})} \right ]<em>{f(x)=f</em>{t-1}(x)}= \frac{y_{i}}{(1+e^{y_{i}f(x)})} $  </p><p>​对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为：</p><p>​$c_{tj} = argmin_{c}\sum_{x_{i}\in R_{tj}}log(1+exp(-y_{i}(f_{t-1}(x_{i})+c)))$</p><p>​上面的式子优化比较难，所以取近似值：</p><p>​$c_{tj} = \sum_{x_{i}\in R_{tj}}r_{ti}/\sum_{x_{i}\in R_{tj}}|r_{ti}|(1-|r_{ti}|)$ </p><h3 id="4-2-多元-GBDT-分类算法"><a href="#4-2-多元-GBDT-分类算法" class="headerlink" title="4.2 多元 GBDT 分类算法"></a>4.2 多元 GBDT 分类算法</h3><p>​损失函数为：</p><p>​$L(y,f(x)) = -\sum_{k=1}^{K}y_{k}log(p_{k}(x))$ </p><p>​样本输出类别为 k，那么 $y_{k}=1$，其余类别 $y_{k}=0$，类别 $k$ 的概率 $p_{k}(x)$ 的表达式为：</p><p>​$p_{k}(x) = exp(f_{k}(x))/\sum_{l=1}^{K}exp(f_{l}(x))$ </p><p>​根据以上两式求得负梯度误差为：</p><p>​$r_{til} = -\left [\frac{\partial L\left(y_{i},f(x_{i})\right)}{\partial f(x_{i})}\right]<em>{f</em>{k}(x)=f_{l,t-1}(x)}=y_{il}-p_{l,t-1}(x_{i})$ </p><p>​误差其实就是样本 $i$ 对应类别 $l$ 的真是概率和 $t-1$ 轮预测值的差值</p><p>​对于生成决策树的叶子结点，最佳的负梯度拟合值为：</p><p>​$c_{tjl} = argmin_{c_{jl}}\sum_{i=0}^{m}\sum_{k=1}^{K}L(y_{k},f_{t-1,l}(x)+\sum_{j=0}^{J}c_{jl}I(x_{i}\in R_{tjl}))$ </p><p>​可用下式近似替代：</p><p>​$c_{tjl} = \frac{K-1}{K}\frac{\sum_{x_{i}\in R_{tjl}}r_{til}}{\sum_{x_{i}\in R_{til}}|r_{til}|(1-|r_{til}|)}$</p><p>​</p><p>​ </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adaboost算法原理</title>
      <link href="/2022/03/17/Adaboost%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/17/Adaboost%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Adaboost-算法原理"><a href="#Adaboost-算法原理" class="headerlink" title="Adaboost 算法原理"></a>Adaboost 算法原理</h1><p>​$Bboosting$ 算法的代表算法是 $Adaboost$ 算法，它即可用于分类，也可用作回归。</p><p>​$Boosting$ 算法需要解决的问题：</p><ol><li>如何计算误差率</li><li>如何学习弱学习器的权重系数</li><li>如何更新样本权重</li><li>使用何种结合策略</li></ol><h2 id="1-Adaboost-算法步骤"><a href="#1-Adaboost-算法步骤" class="headerlink" title="1. Adaboost 算法步骤"></a>1. Adaboost 算法步骤</h2><p>输入：训练数据集 $T={(x_{1},y_{1}),(x_{2},y_{2}),\dots,(x_{n},y_{n})}$，$y_{i}\in Y={-1,1}$，弱学习算法</p><p>输出：最终分类器 $G(x)$</p><p>（1）初始化训练数据的权值分布 $D_{1} = (w_{11},\dots,w_{1i},\dots,w_{1n})$，$w_{1i} = \frac{1}{N}$，$i=1,2,\dots,N$</p><p>​  <strong>说明：</strong>初始时训练数据集是均匀分布的，每个训练样本在基本分类器的学习中作用相同，在原始样本上学习基本分类器$G_{1}(x)$ </p><p>（2）对 $m=1,2\dots,M$</p><p>​（a）使用具有权值分布 $D_{m}$ 的训练数据集学习，得到基本分类器 $G_{m}(x)$</p><p>​（b）计算 $G_{m}(x)$ 在训练数据集上的分类误差率</p><p>​$e_{m} = P(G_{m}(x)\ne y_{i})=\sum_{i=1}^{N}w_{mi}I(G_{m}(x_{i})\ne y_{i})$</p><p>​<strong>说明：</strong>$G_{m}(x)$ 在加权的训练数据集上的分类误差率是被$G_{m}(x)$误分类样本的权值之和</p><p>​（c）计算$G_{m}(x)$ 的系数</p><p>​$a_{m} = \frac{1}{2}log\frac{1-e_{m}}{e_{m}}$ ，这里对数是自然对数</p><p>​<strong>说明：</strong> $\alpha_{m}$表示$G_{m}(x)$在最终分类器的重要性，当$e_{m}\le\frac{1}{2}$ 时，$\alpha_{m}\ge 0$，并且$\alpha_{m}$随着$e_{m}$的减小而增大，所以分类误差率越小的基本分类器在最终分类器中的作用越大</p><p>​（d）更新训练数据集的权值分布</p><p>​$D_{m+1} = (w_{m+1,1},\dots,w_{m+1,i}\dots,w_{m+1,N})$</p><p>​$w_{m+1,i} = \frac{w_{mi}}{Z_{m}}exp(-\alpha_{m}y_{i}G_{m}(x_{i})),i=1,2\dots,N$</p><p>​这里，$Z_{m}$ 是规范化因子：</p><p>​$Z_{m} = \sum_{i=1}^{N}w_{mi}exp(-\alpha_{m}y_{i}G_{m}(x_{i}))$ </p><p>​<strong>说明：</strong> 当 $G_{m}(x_{i})=y_{i}$，$w_{m+1,i} = \frac{w_{mi}}{Z_{m}}e^{-\alpha_{m}}$，当 $G_{m}(x_{i})\ne y_{i}$ ，$w_{m+1,i}=\frac{w_{mi}}{Z_{m}}e^{\alpha_{m}}$ ，由此可以看出被误分类的样本权值增大，被正确分类的样本权值减小，两相比较，误分类样本的权值被放大 $e^{2\alpha_{m}} = \frac{e_{m}}{1-e_{m}}$ </p><p>（3）构建基本分类器的线性组合</p><p>​$f(x) = \sum_{m=1}^{M}\alpha_{m}G_{m}(x)$</p><p>​   得到最终分类器 </p><p>​$G(x) = sign(f(x)) =sign\left( \sum_{m=1}^{M}\alpha_{m}G_{m}(x)\right)$ </p><h2 id="2-Adaboost算法的解释"><a href="#2-Adaboost算法的解释" class="headerlink" title="2. Adaboost算法的解释"></a>2. Adaboost算法的解释</h2><p>​Adaboost算法可以被认为是模型为加法模型、损失函数为指数函数、学习算法为前向分步算法的二类分类学习算法。</p><h3 id="2-1-前向分步算法"><a href="#2-1-前向分步算法" class="headerlink" title="2.1 前向分步算法"></a>2.1 前向分步算法</h3><p>加法模型为：</p><p>$f(x) = \sum_{m=1}^{M}\beta_{m}b(x;\gamma_{m})$ </p><p>其中 $b(x;\gamma_{m})$为基函数，$\gamma_{m}$ 为基函数的参数，$\beta_{m}$为基函数的系数</p><p>在给定训练数据及损失函数  $L(y,f(x))$ 的条件下，学习加法模型 $f(x)$ 就是最小化损失函数：</p><p>$min_{\beta_{m},\gamma_{m}}\sum_{i=1}^{N}L(y_{i},\sum_{m=1}^{M}\beta_{m}b(x_{i};\gamma_{m}))$</p><p>这是一个很复杂的优化问题，前向分步算法求解这一优化问题的想法是：因为学习的是加法模型，如果能从前往后，每一步只学习一个</p><p>基函数及其系数，逐步逼近优化目标函数，那么就可以简化优化的复杂度，具体来说，就是每步只需要优化如下损失函数：</p><p>$min_{\beta,\gamma}\sum_{i=1}^{N}L(y_{i},\beta b(x_{i};\gamma))$ </p><p>前向分步算法的步骤：</p><p>输入：训练数据集$T={(x_{i},y_{i}),(x_{2},y_{2},\dots,(x_{N},y_{N}))}$，损失函数为$L(y,f(x))$，基函数集${b(x;\gamma)}$ </p><p>输出：加法模型</p><p>（1）初始化 $f_{0}(x)=0$</p><p>（2）对 $m=1,2,\dots,M$</p><p>​（a）极小化损失函数</p><p>​$(\beta_{m},\gamma_{m}) = argmin_{\beta,\gamma}\sum_{i=1}^{N}L(y_{i},f_{m-1}(x_{i})+\beta b(x_{i};\gamma))$ , 得到参数 $\beta_{m}$，$\gamma_{m}$</p><p>​（b）更新 </p><p>​$f_{m}(x) = f_{m-1}(x)+\beta_{m}b(x;\gamma_{m})$ </p><p>（3）得到加法模型</p><p>​$f(x) = f_{M}(x) = \sum_{m=1}^{M}\beta_{m}b(x;\gamma_{m})$ </p><h3 id="2-2-前向分步算法与Adaboost"><a href="#2-2-前向分步算法与Adaboost" class="headerlink" title="2.2 前向分步算法与Adaboost"></a>2.2 前向分步算法与Adaboost</h3><p>Adaboost算法是加法模型，学习算法为前向分步算法，损失函数为指数函数的分类问题。</p><p>模型为：</p><p>$f_{k}(x) = f_{k-1}(x)+\alpha_{k}G_{k}(x)$</p><p>损失函数为：</p><p>$argmin_{\alpha,G}\sum_{i=1}^{m}exp(-y_{i}f_{k}(x))$</p><p>$argmin_{\alpha,G}\sum_{i=1}^{m}exp[(-y_{i})(f_{k-1}(x)+\alpha G(x))]$</p><p>令 $w_{ki} = exp(-y_{i}f_{k-1}(x))$ ，它的值不依赖 $\alpha,G$，因此与最小化无关，代入得到：</p><p>$argmin_{\alpha,G}\sum_{i=1}^{m}w_{ki}exp[-y_{i}\alpha G(x)]$ </p><p>第一步先求 $G_{k}(x)$</p><p>$\sum_{i=1}^{m}w_{ki}exp(-y_{i}\alpha G(x_{i})) =$</p><p> $\sum_{y_{i}=G_{k}(x_{i})}w_{ki}e^{-\alpha} + \sum_{y_{i}\ne G_{k}(x_{i})}w_{ki}e^{\alpha} =$ </p><p>$ (e^{\alpha}-e^{-\alpha})\sum_{i=1}^{m}w_{ki}I(y_{i}\ne G_{k}(x_{i})) + e^{-\alpha}\sum_{i=1}^{m}w_{ki}$ </p><p>因为 $w_{ki}$ 和 $\alpha$ 和 $G$ 无关，所以 $G_{k}(x) = argmin_{G}\sum_{i=1}^{m}w_{ki}I(y_{i}\ne G(x_{i}))$ </p><p>将 $G_{k}(x)$ 代入损失函数，并对 $\alpha$ 求导并令其为 0，可得：</p><p>$\alpha_{k} = \frac{1}{2}log\frac{1-e_{k}}{e_{k}}$ </p><p>其中，$e_{k}$ 即为分类误差率：</p><p>$e_{k} = \frac{\sum_{i=1}^{m}w_{ki}I(y_{i}\ne G(x_{i}))}{\sum_{i=1}^{m}w_{ki}} = \sum_{i=1}^{m}w_{ki}I(y_{i}\ne G(x_{i}))$ </p><p>样本权重更新：</p><p>利用 $f_{k}(x) = f_{k-1}(x) + \alpha_{k}G_{k}(x)$ 和 $w_{ki} = exp(-y_{i}f_{k-1}(x))$ </p><p>$w_{k+1,i} = exp(-y_{i}f_{k}(x))$ </p><p>$w_{k+1,i} = w_{ki}exp[-y_{i}\alpha_{k}G_{k}(x)]$</p><p>这样就得到了样本的权重更新公式</p><h2 id="3-Adaboost回归问题的算法流程"><a href="#3-Adaboost回归问题的算法流程" class="headerlink" title="3. Adaboost回归问题的算法流程"></a>3. Adaboost回归问题的算法流程</h2><p>Adaboost回归算法的变种有很多，这里介绍 Adaboost R2 回归算法过程。</p><p>输入：样本集 $T={(x_{1},y_{1}),(x_{2},y_{2}),\dots,(x_{m},y_{m})}$，弱学习器算法，弱学习器迭代次数 $K$ </p><p>输出：最终的强学习器 $f(x)$ </p><p>（1）初始化样本集权重为</p><p>​$D(1) = (w_{11},w_{12},\dots,w_{1m}); w_{1i}=\frac{1}{m}; i=1,2,\dots,m$</p><p>（2）对于 $k=1,2,\dots,K$</p><p>​（a）使用具有权重 $D_{k}$ 的样本集来训练数据，得到弱学习器 $G_{k}(x)$</p><p>​（b）计算训练集上的最大误差</p><p>​ $E_{k} = max|y_{i}-G_{k}(x_{i})|$，  $i=1,2,\dots,m$ </p><p>​（c）计算每个样本的相对误差：</p><p>​  线性误差：$e_{ki} = \frac{|y_{i}-G_{k}(x_{i})|}{E_{k}}$ </p><p>​  平方误差：$e_{ki} = \frac{(y_{i}-G_{k}(x_{i}))^{2}}{E_{k}^{2}}$</p><p>​  指数误差：$e_{ki} = 1-exp(\frac{-|y_{i}-G_{k}(x_{i})|}{E_{k}})$</p><p>​（d）计算回归误差率</p><p>​$e_{k} = \sum_{i=1}^{m}w_{ki}e_{ki}$</p><p>​（e）计算弱学习的系数</p><p>​$\alpha_{k} = \frac{e_{k}}{1-e_{k}}$</p><p>​（f）更新样本集的权重分布 </p><p>​$w_{k+1,i} = \frac{w_{ki}}{Z_{k}}\alpha_{k}^{1-e_{ki}}$</p><p>​其中 $Z_{k} = \sum_{i=1}^{m}w_{ki}\alpha_{k}^{1-e_{ki}}$，为规范化因子</p><p>（3）构建最终强学习器</p><p>​$f(x) = G_{k^{\ast}}(x)$，其中 $G_{k^{\ast}}(x)$ 是所有 $ln\frac{1}{\alpha_{k}},k=1,2\dots K$  的 中位数值乘以对应 $k^{\ast}$ 对应的弱学习器。</p><h2 id="4-Adaboost算法的正则化"><a href="#4-Adaboost算法的正则化" class="headerlink" title="4. Adaboost算法的正则化"></a>4. Adaboost算法的正则化</h2><p>Adaboost算法也会产生过拟合，我们也可以在算法中加入正则化项，这个正则化通常叫做步长，定义为 $\nu$ ，之前弱学习器的迭代公式为：</p><p>​$f_{k}(x) = f_{k-1}(x)+\alpha_{k}G_{k}(x)$</p><p> 加上正则化，就有：</p><p>​$f_{k}(x) = f_{k-1}(x)+\nu\alpha_{k}G_{k}(x)$ </p><p>$\nu$ 的取值范围为 $0&lt;\nu\le1$，对于同样的训练集，较小的 $\nu$ 意味着需要更多的弱学习器进行迭代。</p><h2 id="5-提升树"><a href="#5-提升树" class="headerlink" title="5. 提升树"></a>5. 提升树</h2><p>对于 Adaboost 算法，如果弱学习器是分类树或者回归树，那么就是提升树。</p><p>提升树模型实际上采用的是加法模型与前向分步算法，对分类问题采用的是二叉分类树，对回归问题采用的是二叉回归树。提升树模型</p><p>可以表示为决策树的加法模型：</p><p>$f_{M}(x) = \sum_{m=1}^{M}T(x;\theta_{m})$</p><p>其中，$T(x;\theta_{m})$ 表示决策树，$\theta_{m}$ 为决策树的参数，$M$ 为树的个数</p><p>对于二类分类问题，提升树算法只需将 $Adaboost$ 算法中的基本分类器换成二类分类树即可，其他一样。</p><p>主要介绍回归问题中的提升树算法</p><p>$f_{M}(x) = \sum_{m=1}^{M}T(x;\theta_{m})$ </p><p>在前向分步的第 $m$ 步，给定当前模型 $f_{m-1}(x)$，需求解</p><p>$\theta_{m} = argmax_{\theta_{m}}\sum_{i=1}^{N}L(y_{i},f_{m-1}(x_{i})+T(x_{i};\theta_{m}))$ </p><p>如果损失函数是平方差损失函数：</p><p>$L(y,f_{m-1}(x)+T(x;\theta_{m}))=[y-f_{m-1}(x)-T(x;\theta_{m})]^{2}=[r-T(x;\theta_{m})]^{2}$</p><p>$r = y - f_{m-1}(x)$，我们称 $r$ 为当前模型拟合数据的残差，所以后面的决策树只需模拟当前模型的残差，就能得到最终的模型</p><p>回归问题的提升树算法：</p><p>输入：训练数据集 $T={(x_{1},y_{1}),(x_{2},y_{2}),\dots,(x_{N},y_{N})}$</p><p>输出：提升树 $f_{M}(x)$ </p><p>（1）初始化 $f_{0}(x) = 0$</p><p>（2）对 $m = 1,2,\dots,M$</p><p>​  （a）计算残差</p><p>​ $r_{mi} = y_{i}-f_{m-1}(x_{i}),i=1,2,\dots,N$</p><p>​  （b）拟合残差 $r_{mi}$ 学习一个回归树，得到 $T(x;\theta_{m})$</p><p>​  （c）更新 $f_{m}(x) = f_{m-1}(x) + T(x;\theta_{m})$</p><p>（3）得到回归问题的提升树</p><p>​$f_{M}(x) = \sum_{m=1}^{M}T(x;\theta_{m})$ </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集成学习</title>
      <link href="/2022/03/17/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/17/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="集成学习原理"><a href="#集成学习原理" class="headerlink" title="集成学习原理"></a>集成学习原理</h1><p>​集成学习是目前非常流行的机器学习方法，它本身不是一个单独的机器学习方法，而是通过构建并结合多个机器学习器来完成学习任务，可用于分类问题集成，回归问题集成，特征选取集成，异常点检测集成等。</p><p>集成学习通过训练出若干个体学习器，通过一定的结合策略，就可以最终形成一个强学习器，集成学习主要需要解决两个问题：</p><ul><li>如何得到若干个个体学习器</li><li>如何选择结合策略</li></ul><h2 id="1-集成学习的个体学习器"><a href="#1-集成学习的个体学习器" class="headerlink" title="1. 集成学习的个体学习器"></a>1. 集成学习的个体学习器</h2><p>如何得到若干个个体学习器？主要有两个方法：</p><ul><li>所有个体学习器都是一个种类的，或称为同质的，比如都是决策树或者都是神经网络</li><li>所有个体学习器不都是一个种类的，或称为异质的，比如说可以同时学习出支持向量机学习器，逻辑回归学习器和朴素贝叶斯学习器</li></ul><p>使用的最多的是同质学习器，而同质学习器中，个体学习器使用的最多的是 $CART$ 决策树和神经网络。</p><p>又可以按个体学习器之间是否存在依赖关系进行分类：</p><ul><li>个体学习器之间存在强依赖关系，学习器之间需要串行生成，代表算法是 $boosting$ 系列算法</li><li>个体学习器之间不存在强依赖关系，学习器之间可以并行生成，代表算法是 $bagging$ 和随机森林系列算法</li></ul><h2 id="2-集成学习之boosting"><a href="#2-集成学习之boosting" class="headerlink" title="2. 集成学习之boosting"></a>2. 集成学习之boosting</h2><p><img src="/images/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/image-20220317105033109.png" alt="Boosting算法"></p><p>​$Boosting$ 算法的工作机制首先是按照初始化的训练样本权重（一般是平均权重）学习出一个弱学习器，然后根据弱学习器的学习误差率来更新训练样本的权重，使得弱学习器 1 分类错误的样本权重变高，在后面的学习器中便会重视这些样本，然后通过更新后的权重来训练弱学习器 2，依次进行，直到弱学习器达到事先指定的数目 $T$ ，最终将这 $T$ 个弱学习器通过结合策略进行整合，得到最终的强学习器。</p><p>​$Boosting$ 系列算法里最著名的算法主要有 $AdaBoost$ 算法和 提升树系列算法，提升树算法里面使用的最多的是梯度提升树。</p><h2 id="3-集成学习之-bagging"><a href="#3-集成学习之-bagging" class="headerlink" title="3. 集成学习之 bagging"></a>3. 集成学习之 bagging</h2><p>Bagging算法中，弱学习器之间没有依赖关系，学习器可以并行生成</p><p><img src="/images/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/image-20220317111004796.png" alt="Bagging算法"></p><p>Bagging中个体学习器的训练集是通过采样得到的，采样出 $T$ 个样本集，就能训练出 $T$ 个弱学习器，再通过结合策略得到强学习器。</p><p>这里的采样法一般使用自主采样法，即对 m 个样本的数据集，每次采取一个样本，然后放回后重新采样，这样采集 m 次，就能得到一个 m </p><p>个样本的采样集，且一个样本集中可以包含多个一样的样本，也就是可以重复。</p><h2 id="4-集成学习之结合策略"><a href="#4-集成学习之结合策略" class="headerlink" title="4. 集成学习之结合策略"></a>4. 集成学习之结合策略</h2><p>​<strong>平均法</strong></p><p>​对于回归预测问题，通常使用的结合策略是平均法，对弱学习器的输出进行平均得到最终的输出。</p><p>求平均时可以给每个弱学习器加权重</p><p>​算术平均：</p><p>​$H(x) = \frac{1}{T}\sum_{1}^{T}h_{i}(x)$</p><p>​若每个学习器有个权重 $w$ ，则</p><p>​$H(x) = \sum_{i=1}^{T}w_{i}h_{i}(x)$</p><p>​所有弱学习器的权重相加等于 1</p><p>​<strong>投票法</strong></p><p>​对于分类问题，通常使用的是投票法</p><ul><li>相对多数投票法，即选最多的类别作为输出</li><li>绝对多数投票法，即不仅要最多，而且票数还要过半，没有过半拒绝预测</li><li>加权投票法，即每一个分类器都有个权重，最终输出各个分类器加权票数最高的类别</li></ul><p>​<strong>学习法</strong></p><p>​代表方法是 $stacking$ ，不是对弱分类器结果进行简单的逻辑处理，而是加一个学习器，将弱学习器的所有输出当作输入，将样本输出作为输出，也就是说每个弱学习器就是一个特征，最终得到一个学习器来得到最终结果</p><p><img src="/images/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/image-20220513165044590.png" alt="image-20220513165044590"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朴素贝叶斯算法</title>
      <link href="/2022/03/16/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/16/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h1><p>​朴素贝叶斯算法是基于贝叶斯定理和特征条件独立假设的分类算法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布，然后基于此模型，对给定的输入 $x$ , 利用贝叶斯定理求出后验概率最大的类别作为输出，朴素贝叶斯算法实现简单，学习与预测效率都很高，是一种常用的方法。</p><h2 id="相关统计学知识"><a href="#相关统计学知识" class="headerlink" title="相关统计学知识"></a>相关统计学知识</h2><p>​1. 条件独立公式</p><p>​$P(X,Y) = P(X)P(Y)$ </p><ol start="2"><li>条件概率公式</li></ol><p>​$P(Y|X) = P(X,Y)/P(X)$</p><p>​$P(X|Y) = P(X,Y)/P(Y)$ </p><ol start="3"><li><p>全概率公式</p><p>$P(X) = \sum_{k}P(X|Y=Y_{k})$，其中 $\sum_{k}P(Y_{k})=1$</p></li><li><p>贝叶斯公式</p><p>$P(Y_{k}|X) = \frac{P(X|Y_{k})P(Y_{k})}{\sum_{k}P(X|Y=Y_{k})P(Y_{k})}$</p></li></ol><h2 id="朴素贝叶斯的模型"><a href="#朴素贝叶斯的模型" class="headerlink" title="朴素贝叶斯的模型"></a>朴素贝叶斯的模型</h2><p>朴素贝叶斯通过训练数据集学习联合概率分布 $P(X,Y)$，具体的学习：</p><p><strong>先验概率：</strong> $P(Y=c_{k}), k = 1,2,\dots,K$</p><p><strong>条件概率：</strong> $P(X=x|Y=c_{k}) = P(X^{(1)}=x^{(1)},\dots,X^{(n)}=x^{(n)}|Y=c_{k}), k=1,2,\dots,K$ </p><p>根据以上概率分布就能够学习到联合概率分布 $P(X,Y)$ ，但是有个问题</p><p>条件概率 $P(X=x|Y=c_{k})$ 有指数级数量的参数，假设 $x^{(j)}$ 有 $S_{j}$ 个取值，$Y$ 可取值有 $K$ 个，那么参数的个数为 $K\prod_{j=1}^{n}S_{j}$ </p><p>但是朴素贝叶斯法对条件概率分布作了条件独立性的假设，即：</p><p>$P(X=x|Y=c_{k}) = P(X^{(1)},\dots,X^{(n)}=x^{(n)}|Y=c_{k}) = \prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_{k})$</p><p>朴素贝叶斯在分类时，对给定的输入 $x$ ，通过学习到的模型计算后验概率分布 $P(Y=c_{k}|X=x)$，将后验概率最大的类作为 $x$ 的类输出。</p><p>后验概率公式为：</p><p>$P(Y=c_{k}|X=x) = \frac{P(X=x|Y=c_{k})P(Y=c_{k})}{\sum_{k}P(X=x|Y=c_{k})P(Y=c_{k})}$ </p><p>根据条件独立性假设又可得：</p><p>$P(Y=c_{k}|X=x) = \frac{P(Y=c_{k})\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_{k})}{\sum_{k}(P(Y=c_{k})\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_{k}))}$ </p><p>于是朴素贝叶斯分类器表示为：</p><p>$y = f(x) = arg\max_{c_{k}}\frac{P(Y=c_{k})\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_{k})}{\sum_{k}(P(Y=c_{k})\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_{k}))}$ </p><p>由于分母都是相同的，所以有：</p><p>$y = f(x) = arg\max_{c_{k}}P(Y=c_{k})\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_{k})$ </p><h2 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h2><p>朴素贝叶斯法中的学习意味着要估计 $P(Y=c_{k})$ 和 $P(X^{(j)}=x^{(j)}|Y=c_{k})$ ，可以应用极大似然估计法估计相应的概率。</p><p>$P(Y=c_{k})$ 的极大似然估计为：</p><p>$P(Y=c_{k}) = \frac{\sum_{i=1}^{N}I(y_{i}=c_{k})}{N}, k = 1,2,\dots,K$</p><p>第 $j$ 个特征 $x^{(j)}$ 可能的取值的集合为 ${a_{j1},a_{j2},\dots,a_{js}}$，条件概率 $P(X^{(j)}=a_{jl}|Y=c_{k})$ 的极大似然估计为：</p><p>$P(X^{(j)}=a_{jl}|Y=c_{k}) = \frac{\sum_{i=1}^{N}I(x_{i}^{(j)}=ajl, y_{i}=c_{k})}{\sum_{i=1}^{N}I(y_{i}=c_{k})}, j=1,2,\dots,n;$    $l=1,2,\dots,S_{j};$     $k=1,2,\dots,K$  </p><p>上面的 $I$ 是 $0-1$ 损失函数：</p><h2 id="朴素贝叶斯算法的流程"><a href="#朴素贝叶斯算法的流程" class="headerlink" title="朴素贝叶斯算法的流程"></a>朴素贝叶斯算法的流程</h2><p>输入：训练数据 $T={(x_{1},y_{1}),(x_{2},y_{2}),\dots,(x_{n},y_{n})}$，$a_{jl}$ 是第 $j$ 个特征可能取的第 $l$ 个值，$j=1,2,\dots,n$，$l=1,2,\dots,S_{j}$ </p><p>输出：实例 $x$ 的分类</p><ol><li>计算先验概率以及条件概率：</li></ol><p>​$P(Y=c_{k}) = \frac{\sum_{i=1}^{N}I(y_{i}=c_{k})}{N}, k = 1,2,\dots,K$</p><p>​$P(X^{(j)}=a_{jl}|Y=c_{k}) = \frac{\sum_{i=1}^{N}I(x_{i}^{(j)}=ajl, y_{i}=c_{k})}{\sum_{i=1}^{N}I(y_{i}=c_{k})}, j=1,2,\dots,n;$ </p><p>​ 2. 对于给定的实例计算：</p><p>​$P(Y=c_{k})\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_{k}), k=1,2,\dots,K$ </p><p>​  3. 确定实例 $x$ 的类</p><p>​$y = f(x) = arg\max_{c_{k}}P(Y=c_{k})\prod_{j}P(X^{(j)}=x^{(j)}|Y=c_{k})$</p><h2 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h2><p>用极大似然估计可能会出现所要估计的概率值为 0 的情况，这时会影响到后验概率的计算结果，使分类误差产生偏差，解决这一问题是采用贝叶斯估计，具体的，</p><p>条件概率的贝叶斯估计是：</p><p>$P_{\lambda}(X^{(j)}=a_{jl}|Y=c_{k}) = \frac{\sum_{i=1}^{N}I(x_{i}^{(j)}=ajl, y_{i}=c_{k})+\lambda}{\sum_{i=1}^{N}I(y_{i}=c_{k})+S_{j}\lambda}$ </p><p>先验概率的贝叶斯估计是：</p><p>$P_{\lambda}(Y=c_{k}) = \frac{\sum_{i=1}^{N}I(y_{i}=c_{k})+\lambda}{N+\lambda}$  </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树算法原理</title>
      <link href="/2022/03/14/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/14/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树算法原理"><a href="#决策树算法原理" class="headerlink" title="决策树算法原理"></a>决策树算法原理</h1><h2 id="1-信息论基础"><a href="#1-信息论基础" class="headerlink" title="1. 信息论基础"></a>1. 信息论基础</h2><p>​<strong>决策树的思想：</strong> 类似于 if - else 语句，但是决策树可选择的条件很多，于是就有一个这个问题，有这么多条件，到底优先选择哪个条件呢？如何衡量条件选择的优劣是决策树的关键，接下来介绍的信息论中的熵就是解决这个问题。</p><p>​<strong>熵的概念：</strong> 熵度量了事物的不确定性，越不确定的事物，它的熵越大。随机变量 $X$ 的熵的表达式为：</p><p>​$H(X) = -\sum_{i=1}^{n}p_{i}log p_{i}$</p><p>​其中 n 代表 $X$ 的 n 种不同的离散值，$p_{i}$ 代表了 $X$ 取值为 i 的概率，$log$ 是以 2 或者 $e$ 为底 </p><p>​<strong>联合熵：</strong> $H(X,Y) = -\sum_{x_{i}\in X}\sum_{y_{i}\in Y}p(x_{i},y_{i})logp(x_{i},y_{i})$ </p><p>​<strong>条件熵：</strong> 度量了我们在知道 $Y$ 以后，$X$ 剩下的不确定性。表达式为：</p><p>​$H(X|Y) = \sum_{j=1}^{n}p(y_{j})H(X|y_{j})$ ，其中 n 表示 $Y$ 可以取值的个数</p><p>​<strong>互信息（信息增益）：</strong> $X$ 在知道了 $Y$ 以后不确定性的减少程度，记为 $I(X,Y)$ ，在决策树中这个叫信息增益，$ID3$ 算法就是用信息</p><p>增益来判断当前结点应该用什么特征来构建决策树，信息增益大，则越适合用来分类。</p><h2 id="2-决策树-ID3-算法"><a href="#2-决策树-ID3-算法" class="headerlink" title="2. 决策树 ID3 算法"></a>2. 决策树 ID3 算法</h2><p>​<strong>算法输入</strong>：m 个样本，样本输出集合为 $D$ ，每个样本有 n 个离散特征，特征集合即为 $A$。</p><p>​<strong>算法输出：</strong> 决策树 $T$ </p><p>​<strong>算法流程：</strong> </p><ol><li><p>初始化信息增益的 阈值 $\epsilon$ </p></li><li><p>判断样本是否都属于同一类输出 $D_{i}$，如果是则返回单节点树 $T$，标记为 $D_{i}$ </p></li><li><p>判断剩余可待选择的特征是否为空，如果是则返回单节点树 $T$,  标记为样本中输出类别 $D$ 实例最多的那个类别</p></li><li><p>计算 $A$ 中的各个特征对输出 $D$ 的信息增益，选择信息增益最大的特征类别 $A_{g}$</p></li><li><p>如果 $A_{g}$ 的信息增益小于阈值 $\epsilon$ ，则返回单节点树 $T$ , 标记类别为样本输出类别最多的类别</p></li><li><p>否则，按特征 $Ag$ 的不同取值 $Ag_{i}$ 将对应的样本输出 $D$ 分成不同的类别 $D_{i}$，每个类别只产生一个子节点，对应的特征为 $A_{gi}$，返回增加了节点的树 $ T $</p></li><li><p>对于所有的子节点 ，令 $D = D_{i}$,  $A = A-{A_{g}}$，递归调用 2 - 6 步，得到字数  $T_{i}$</p></li></ol><h2 id="3-决策树-ID3-算法的不足"><a href="#3-决策树-ID3-算法的不足" class="headerlink" title="3. 决策树 ID3 算法的不足"></a>3. 决策树 ID3 算法的不足</h2><ol><li>$ID3$ 算法没有考虑连续特征，所以连续值无法在 $ID3$ 中运用，这很大程度上限制了 $ID3$ 的用途</li><li>$ID3$ 采用信息增益大的特征优先建立决策树结点，但其实有个缺陷，在相同条件下，取值比较多的特征会比取值比较少的特征信息增益大</li><li>$ID3$ 没有对缺失值的情况做考虑</li><li>没有考虑过拟合问题</li></ol><h2 id="4-决策树-C4-5-算法"><a href="#4-决策树-C4-5-算法" class="headerlink" title="4. 决策树 C4.5 算法"></a>4. 决策树 C4.5 算法</h2><p>​$C 4.5$ 算法是对 $ID3$ 算法的一个改进，解决了 $ID3$ 算法的不足之处 。</p><p>​<strong>处理连续特征：</strong></p><p>​m 个样本，其某个特征 $A$ 有 m 个取值，将这 m 个值从小到大排列为 $a_{1},a_{2},\dots a_{m}$，取相邻两个数据的平均值，一共可以取到 m-1 个划分点，其中第 i 个划分点 $T_{i}$ 表示为：$T_{i} = \frac{a_{i}+a_{i+1}}{2}$ ，对于这 m-1 个点，分别计算以该点作为二元分类点时的信息增益。选择信息增益最大的点作为该连续特征的二元离散分类点。例如，取到的增益最大点为 $a_{t}$，则小于 $a_{t}$ 的值为类别 1，大于 $a_{t}$ 的值为类别 2 ，这样就做到了连续特征离散化 。但是不同于离散特征，连续特征在后面的选择中还可以参与子节点的选择过程 。</p><p>​<strong>信息增益比：</strong></p><p>​信息增益容易偏向于取值较多的特征，对于这个问题，引入一个信息增益比的概念，$I_{R}(X,Y)$，它是信息增益和特征熵的比值，表达式如下：<br>​      $I_{R}(D,A) = \frac{I(A,D)}{H_{A}(D)}$</p><p>其中 $D$ 为样本特征输出的集合，$A$ 为样本特征，对于特征熵 $H_{A}(D)$，表达式如下：</p><p>​          $H_{A}(D) = -\sum_{i=1}^{n}\frac{|D_{i}|}{|D|}log_{2}\frac{|D_{i}|}{|D|}$</p><p>其中 n 为特征 A 的类别数，$D_{i}$ 为特征 A 的 第 i 个取值对应的样本数。$|D|$ 为总的样本数。</p><p><strong>缺失值的处理和过拟合问题这里不做介绍</strong></p><h2 id="5-决策树-C4-5-算法的不足"><a href="#5-决策树-C4-5-算法的不足" class="headerlink" title="5. 决策树 $C4.5$ 算法的不足"></a>5. 决策树 $C4.5$ 算法的不足</h2><ol><li>容易过拟合，需要进行剪枝，思路主要有预剪枝和后剪枝，后剪枝即先生成决策树，再通过交叉验证来剪枝。</li><li>$C4.5$ 是多叉树，在很多时候，计算机中的二叉树模型会比多叉树运算效率高。</li><li>$C4.5$ 只能用于分类，不能用于回归。</li><li>$C4.5$ 使用了熵模型，里面有大量的 对数运算，如果是连续特征还有大量的排序运算。</li></ol><p>这 4 个问题在后面的 $CART$ 树里面进行了改进，scikit-learn 的决策树就是使用的 $CART$ 算法。</p><h2 id="6-CART-算法"><a href="#6-CART-算法" class="headerlink" title="6. CART 算法"></a>6. CART 算法</h2><h3 id="CART-树选择最优特征的方法"><a href="#CART-树选择最优特征的方法" class="headerlink" title="CART 树选择最优特征的方法"></a>CART 树选择最优特征的方法</h3><p>$ID3$ 算法中使用信息增益来选择特征，$C4.5$ 中选择信息增益比来选择特征，这两者都是基于信息论的熵模型的，涉及大量的对数运算。</p><p>$CART$ 算法使用的是基尼系数，以此来替代前两者中的信息增益，基尼系数代表了模型的不纯度，基尼系数越小，则不纯度越低，特征越</p><p>好，和信息增益（比）相反，信息增益（比）是越大越好。</p><p><strong>基尼系数：</strong></p><p>假设一个随机变量有 $K$ 个取值，第 $K$ 个取值的概率为 $p_{k}$，则基尼系数的表达式为：</p><p>$Gini(p) = \sum_{k=1}^{K}p_{k}(1-p_{k}) = 1 - \sum_{k=1}^{K}p_{k}^2$ </p><p>如果是二分类问题，基尼系数表达式为：</p><p>$Gini(p) = 2p(1-p)$ </p><p>对于给定的样本 $D$，假设有 $K$ 个类别，第 k 个类别的数量为 $C_{k}$，则样本 $D$ 的基尼系数表达式为：</p><p>$Gini(D) = 1 - \sum_{k=1}^{K}(\frac{|C_{k}|}{|D|})^{2}$</p><p>类似于条件熵，如果根据特征 $A$ 将样本 $D$ 分成了 $D1$ 和 $D2$，则在特征 $A$ 的条件下，D 的基尼系数为：</p><p>$Gini(D,A) = \frac{|D1|}{|D|}Gini(D1) + \frac{|D2|}{D}Gini(D2)$</p><h3 id="CART算法对连续特征和离散特征的改进"><a href="#CART算法对连续特征和离散特征的改进" class="headerlink" title="CART算法对连续特征和离散特征的改进"></a>CART算法对连续特征和离散特征的改进</h3><p><strong>连续特征：</strong> 和 $C4.5$ 基本一样，唯一改变的地方就是 $CART$ 算法是使用基尼系数（方差）来选择特征。还要注意：连续特征在后面的选择中仍然可</p><p>以参与子节点的产生过程。</p><p><strong>离散特征：</strong> 在 $ID3$ 和 $C4.5$ 中，某个特征被选取后，如果他有 n 个取值，就会在决策树上建立 n 个子节点，这导致了决策树是一个多叉</p><p>树。但是 $CART$ 算法不同，它是不停的二分，例如，一个特征 $A$ , 它有 3 个 类别分别是 $A_{1},A_{2},A_{3}$，$CART$ 算法会考虑以下几种情况：</p><ul><li>${A_{1}}$和 ${A_{2},A_{3}}$</li><li>${A_{2}}$ 和 ${A_{1},A_{3}}$</li><li>${A_{3}}$ 和 ${A_{1},A_{2}}$</li></ul><p>找到基尼系数最小的组合，假设是 第一组 ${A_{1}}$ 和 ${A_{2},A_{3}}$ , 那么建立两个结点，一个是 ${A_{1}}$ , 一个是 ${A_{2},A_{3}}$ , 由于这次没有将 特征</p><p>$A$ 的取值完全分开，所以在后面选择特征的时候还可以继续选择特征 $A$ 来将 $A_{2}$ 和 $A_{3}$ 分开，这与前两个算法不同。</p><h3 id="CART-分类树建立的算法流程"><a href="#CART-分类树建立的算法流程" class="headerlink" title="CART 分类树建立的算法流程"></a>CART 分类树建立的算法流程</h3><p>算法输入：训练集 $D$ ，基尼系数的阈值，样本个数阈值</p><p>算法输出：决策树 $T$</p><ol><li>对于当前结点的数据集 $D$，如果样本个数小于阈值或者没有特征，则返回决策树，停止递归。</li><li>计算样本集 $D$ 的基尼系数，如果基尼系数小于阈值，则返回决策树，停止递归。</li><li>计算当前结点现有剩余特征及其各个特征值对数据 $D$ 的基尼系数，连续值有连续值的处理方式，离散值有离散值处理的方式。</li><li>选择基尼系数最小的特征 $A$ 和对应的特征值 $a$ ，根据这个最优特征和特征值，把数据集划分成两部分 $D1$ 和 $D2$，同时建立两个结点，左节点数据集为为 $D1$ ，右节点数据集为 $D2$。</li><li>然后递归的执行 1-4 步，生成决策树。</li></ol><p>预测时，某个样本落入某个结点时，预测类别为该结点中概率最大的类别。</p><h3 id="CART-回归树建立算法"><a href="#CART-回归树建立算法" class="headerlink" title="CART 回归树建立算法"></a>CART 回归树建立算法</h3><p>​回归树和分类树大部分地方都是类似的，这里主要介绍不同的地方。</p><p><strong>特征选取的方式不同：</strong></p><p>做分类时采用的是基尼系数来选择特征，那是因为样本输出是离散值，可以计算概率，但是回归时，样本输出是离散值。回归树使用常见的</p><p>方差度量方式，样本数据不论是连续的还是离散的，我们要找到的是一个最优的切分变量 $x^{(j)}$（特征）以及切分点（特征值）, 它会把样本集 $D$ </p><p>划分为两个区域：</p><p>$R_{1}(j,s) = { x|x^{(j)}\le s}$   和  $R_{2}(j,s)={x|x^{(j)}&gt;s }$ </p><p>求解：</p><p>$ min_{j,s}[min_{c_{1}}\sum_{x_{i}\in R_{1}(j,s)}(y_{i}-c_{1})^{2} + min_{c_{2}}\sum_{x_{i}\in R_{2}(j,s)}(y_{i}-c_{2})^2]$  ，其中 $ c_{1}$ 和 $c_{2}$ 就是 $R_{1}$ 和 $R_{2}$ 区域所有样本输出的平均值。也就是</p><p>找特征以及特征值，让划分后两个区域样本输出的平均值之和最小。</p><p><strong>决策树建立后做预测的方式不同：</strong></p><p>​上面介绍的分类树是使用概率最大的类别作为当前结点的预测类别，而回归树是使用结点中样本的均值或者中位数来预测输出结果。</p><h3 id="CART-树的剪枝算法"><a href="#CART-树的剪枝算法" class="headerlink" title="CART 树的剪枝算法"></a>CART 树的剪枝算法</h3><p>决策树算法很容易过拟合，导致泛化能力差，为了解决这个问题，需要对 $CART$  树进行剪枝。</p><p>分类树和回归树的剪枝策略除了在度量损失的时候一个使用均方差，一个使用基尼系数，算法基本完全一样。</p><p><strong>剪枝的损失度量：</strong> 对任意一颗子树 $T$ ，其损失函数为</p><p>$C\alpha(T_{t}) = C(T_{t}) + \alpha|T_{t}|$</p><p>$\alpha$ 是正则化系数，$C(T_{t})$ 为训练数据的预测误差，分类树是用基尼系数度量，回归树是用均方差来度量，$|T_{t}|$ 是子树 T 的叶子节点数量。</p><p>当 $\alpha = 0$ 时，即没有正则化，原始的 $CART$ 树就是最优子树，当 $\alpha = \infty$，惩罚项达到最大，此时原始 $CART$ 树的根节点组成的树即是</p><p>最优子树。这是两种极端的情况，$\alpha$ 越大，剪枝的越厉害，最优子树就会越简单，如果固定 $\alpha$ ，那么一定有一个最优子树与其对应。</p><p> <strong>剪枝的思路：</strong></p><p>​对于一颗子树 $T_{t}$ ，如果没有剪枝，它的损失是：</p><p>​$C_{\alpha}(T_{t}) = C(T_{t}) + \alpha|T_{t}|$ </p><p>​如果将其剪掉，仅仅保留根节点，则损失是：</p><p>​$C_{\alpha}(T) = C(T) + \alpha$</p><p>​当 $\alpha$ 很小时，$C_{\alpha}(T_{t}) &lt; C_{\alpha}(T)$ ，因为整个子树由于预测精准些，自然损失要比只有一个根节点的要小</p><p>​当 $\alpha$ 慢慢增加，会有一个时刻有：</p><p>​$C_{\alpha}(T_{t}) = C_{\alpha}(T)$</p><p>​这时 $\alpha$ 为：</p><p>​$\alpha = \frac{C(T)-C(T_{t})}{|T_{t}|-1}$ </p><p>​$T_{t}$ 和 $T$ 有相同的损失函数，但是 $T$ 更简单，结点更少，所以可以对 $T_{t}$ 剪枝，让其变为 $T$ </p><p>​综上，如果我们计算出每个子树是否剪枝的阈值 $\alpha$ ，然后对这些阈值求出最优子树，再使用交叉验证去选择最好的那棵子树最为最优子树。</p><p><strong>剪枝算法：</strong></p><ol><li><p>初始化 $k = 0, T = T_{0}$，最优子树集合 $ w = {T}$ </p></li><li><p>$\alpha_{min} = \infty$</p></li><li><p>从叶子结点自下而上的计算各内部结点 $t$ 的损失函数 $C_{\alpha}(T_{t})$，叶子结点数 $|T_{t}|$，以及正则化阈值 $\alpha = min{ \frac{C(T)-C(T_{t})}{|T_{t}|-1},\alpha_{min}}$ ，更新 $\alpha_{min} = \alpha$ </p></li><li><p>$\alpha_{k} = \alpha_{min}$ </p></li><li><p>从根节点自上而下访问子树 t 的内部节点，如果有 $\frac{C(T)-C(T_{t})}{|T_{t}|-1}\le \alpha_{k}$ ，进行剪枝，并决定叶节点 t 的预测值，分类树为 概率最大的类</p><p>别，回归树为 均值，这样得到了 $\alpha_{k}$ 对应的最优子树 $T_{k}$</p></li><li><p>最优子树集合 $w = w \cup T_{k}$</p></li><li><p>进行下一轮剪枝，$k = k + 1,T = T_{k}$，如果 $T$ 不是由根节点组成的树，则回到步骤 2 继续递归的执行，否则就已经得到所有可选的最优子树集合 $w$ </p></li><li><p>采用交叉验证在 $w$ 选择最优子树 $T_{\alpha}$</p></li></ol><h2 id="7-决策树优缺点"><a href="#7-决策树优缺点" class="headerlink" title="7. 决策树优缺点"></a>7. 决策树优缺点</h2><p><strong>优点：</strong></p><ol><li>简单直观，生成的决策树很直观。</li><li>基本不需要预处理，不需要提前归一化，处理缺失值。</li><li>使用决策树的预测代价为 $O(log_{2}m)$。</li><li>既可以处理离散值也可以处理连续值。</li><li>可以处理多维度输出的分类问题。</li><li>相比于神经网络之类的黑盒分类模型，决策树在逻辑上可以得到很好的解释。</li><li>可以对决策树进行剪枝，提高泛化能力。</li><li>对于异常点的容错能力好，健壮性高。</li></ol><p><strong>缺点：</strong></p><ol><li>决策树算法非常容易过拟合，导致泛化能力不强，可以设置结点中最少样本数量和限制决策树的深度。</li><li>决策树会因为样本的一点点的改动，就会导致树结构的剧烈变化，这个可以通过集成学习的方法来解决。</li><li>寻找最优的决策树是一个 NP 问题，我们一般是通过启发式方式，容易陷入局部最优，可以通过集成学习的方法来改善。</li><li>有些比较复杂的关系决策树很难学习。</li><li>如果某些特征的样本比例过大，生成的决策树容易偏向于这些特征，可以调节样本权重来改善。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机原理</title>
      <link href="/2022/03/14/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/14/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="感知机原理"><a href="#感知机原理" class="headerlink" title="感知机原理"></a>感知机原理</h1><p>​感知机模型虽然在今天看来它的泛化能力不强，但是它的原理却很值得研究，可以为后面的支持向量机、神经网络做一个铺垫。</p><h2 id="1-感知机模型"><a href="#1-感知机模型" class="headerlink" title="1. 感知机模型"></a>1. 感知机模型</h2><p>​<strong>思想</strong>：即在高维空间中找到一个超平面能够将所有的数据样本分开。<br>​<strong>线性可分性</strong>：如果这个超平面找不到，也就意味着数据是线性不可分的，反之则是线性可分的。这是感知机的缺点，支持向量机在面对线性不可分的情况时，可以采用核技巧来让数据高维可分，神经网络可以通过激活函数和增加隐藏层的方式来让数据线性可分。</p><p>​<strong>数学描述：</strong><br>​对于一些数据样本 $(x_{1}^{(i)},x_{2}^{(i)},\dots x_{n}^{(i)},y_{i}),i=1,2,\dots n$ , 感知机的目标是找到一个超平面，即$\theta_{0} + \theta_{1}x_{1} + \dots +\theta_{n}x_{n} = 0$ ，让其中一种类别的样本满足 $\theta_{0} + \theta_{1}x_{1} + \dots +\theta_{n}x_{n} &gt; 0$，另一种类别的样本满足 $\theta_{0} + \theta_{1}x_{1} + \dots +\theta_{n}x_{n} &lt; 0$，如果数据线性可分，这样的超平面一般不唯一，也就是说感知机模型可以有多个解。</p><p>​为了简化超平面的写法，我们增加一个特征 $x_{0} = 1$，这样超平面为$\sum_{i=0}^{n}\theta_{i}x_{i} = 0$，用向量来表示超平面为 $\theta\cdot x = 0$，其中 $\theta$ 是(n+1)x1维的，x 是 (n+1)x1 的向量。而感知机模型就是：$y = sign(\theta\cdot x)$，其中 sign 是符号函数 。</p><h2 id="2-感知机模型的损失函数"><a href="#2-感知机模型的损失函数" class="headerlink" title="2. 感知机模型的损失函数"></a>2. 感知机模型的损失函数</h2><p>​损失函数是所有误分类点到超平面的距离总和。</p><p>​点 $x_{0}$ 到某个平面上的距离公式：$d = \frac{1}{\left | \theta \right |}|\theta\cdot x_{0}|$ ，这里 $\left | \theta \right |$ 是 $L2$ 范数。</p><p>​对于误分类点$(x_{i},y_{i})$来说满足这个式子： $-y_{i}(\theta\cdot x_{i}) &gt; 0$ ，这是因为当 $\theta\cdot x&gt;0$ 时，$y_{i} = -1$，而当 $\theta\cdot x&lt;0$ 时，$y_{i} = +1$ , 因此误分类点到超平面的距离为：$-\frac{1}{\left | \theta \right |}y_{i}(\theta\cdot x_{i})$  。</p><p>​设误分类点的集合为 $M$，那么所有误分类点到超平面的距离总和为：$-\frac{1}{\left | \theta \right |}\sum_{x_{i}\in M} y_{i}(\theta\cdot x_{i})$ 。不考虑 $\frac{1}{\left | \theta\right |}$ , 就得到了感知机模型的损失函数：$L(\theta) = -\sum_{x_{i}\in M}y_{i}(\theta\cdot x_{i})$，其中 $M$ 为误分类点的集合。</p><h2 id="3-感知机模型损失函数的优化方法"><a href="#3-感知机模型损失函数的优化方法" class="headerlink" title="3. 感知机模型损失函数的优化方法"></a>3. 感知机模型损失函数的优化方法</h2><p>​这个损失函数可以使用梯度下降法或者拟牛顿法来解决，常用的是梯度下降法。</p><p>​由于只有误分类点才能参与损失函数的计算，所以优化方法采用<strong>随机梯度下降法</strong>来进行优化。</p><p>​每次只用一个误分类样本点来计算梯度，假设这个误分类样本点是 $(x_{i},y_{i})$，则梯度下降公式为：</p><p>​$\theta = \theta + \alpha y_{i}x_{i}$ ，其中 $\alpha$ 为步长，$y_{i}$ 为样本输出 1 或者 -1。</p><h2 id="4-感知机模型的原始形式"><a href="#4-感知机模型的原始形式" class="headerlink" title="4. 感知机模型的原始形式"></a>4. 感知机模型的原始形式</h2><p>​算法的输入：$(x_{1}^{(i)},x_{2}^{(i)},\dots x_{n}^{(i)},y_{0})$ </p><p>​算法的输出：分离超平面的模型系数 $\theta$ 向量</p><p>​<strong>执行步骤：</strong></p><ol><li>定义所有 $x_{0}$ 为 1，选择向量 $\theta$ 的初始值和步长 $\alpha$ , 可以将 $\theta$ 初始化为 0 向量，步长设置为 1 ，感知机模型不唯一，这两个初值不同会影响到最终的迭代结果。</li><li>在训练数据集里面选择一个误分类点 $(x_{1}^{(i)},x_{2}^{(i)}\dots x_{n}^{(i)},y_{i})$ ，这个点要满足：$y_{i}\theta\cdot x_{i} &lt;= 0$ 。</li><li>对 $\theta$ 向量进行一次随机梯度下降迭代：$\theta = \theta + \alpha y_{i}x_{i}$ 。</li><li>检查训练集中是否还有误分类点，如果没有算法结束，如果有，跳转到步骤 2 继续执行。</li></ol><h2 id="5-感知机模型的对偶形式"><a href="#5-感知机模型的对偶形式" class="headerlink" title="5. 感知机模型的对偶形式"></a>5. 感知机模型的对偶形式</h2><p>​对偶形式是对算法执行速度的优化，具体如何优化如下：</p><p>​根据原始形式的迭代公式 $\theta = \theta + \alpha y_{i}x_{i}$ 可以看出，我们每次梯度迭代都是选取一个样本来更新 $\theta$ 向量，最终经过若干次的迭代得到最终的结果。对于从来没有被误分类过的样本，它的迭代次数为 0 , 对于被多次误分类过的样本 $j$ , 它参与 $\theta$ 更新的次数设为 $m_{j}$ ，如果 $\theta$ 向量刚开始就初始化为 0 向量，经过多次迭代后 $\theta$ 向量可以表达为：<br>​$\theta = \alpha\sum_{j=1}^{m}m_{j}y_{j}x_{j}$<br>​其中 $m_{j}$ 为样本 $j$ 被误分类的次数，每个样本的 $m_{j}$ 初始值为 0 ，样本 $j$ 每次被误分类时，$m_{j}$ 的值都加 1 。</p><p>​由于步长 $\alpha$ 为常量，我们令 $\beta_{j} = \alpha m_{j}$，这样 $\theta$ 的表达式就为：<br>​$\theta = \sum_{j=1}^{m}\beta_{j}y_{j}x_{j}$ </p><p>​在每一次判断误分类点的时候，本来判断公式为 $y_{i}(\theta\cdot x_{i}) &lt; 0$，现在对偶形式使用如下公式：$y_{i}\sum_{j=1}^{m}\beta_{j}y_{j}x_{j} \cdot x_{i}$ ，<strong>注意</strong> 这里的 $x_{j}$ 和 $x_{j}$ 是内积运算，而这个内积运算在下面的迭代中重复计算，如果在优化前就将内积运算计算完毕并保存下来，优化过程就会更快，省下很多时间，这也就是为什么对偶形式比一般的形式要更优的原因。</p><p>​样本的内积矩阵称为 Gram矩阵 ，它是一个对称矩阵，记为 $G = [x_{i} \cdot x_{j}]$<br>​如果 $(x_{i},y_{i})$ 是误分类样本点，则更新 $\beta_{i} = \beta_{i} + \alpha$<br>​直到没有误分类点，算法执行结束，$\theta = \sum_{j=1}^{m}\beta_{j}y_{j}x_{j}$ </p><p><strong>整体步骤：</strong><br>    1. 定义所有的 $x_{0}$ 为 1 ，步长 $\alpha$ 初值 ，可以将 $\beta$ 设为 0，$\alpha$ 设为 1 。<br>    2. 计算所有样本内积形成的 Gram 矩阵 G 。<br>    3. 在训练集中选择一个误分类点 $(x_{i},y_{i})$ ，这个点应满足：$y_{i}\sum_{j=1}^{m}\beta_{j}y_{j}x_{j} \cdot x_{i} &lt;=0$ ，通过查询 Gram 矩阵的 $g_{ij}$ 的值来快速计算是否小于 0 。<br>    4. 对 $\beta$ 向量的第 i 个分量进行一次更新：$\beta_{i} = \beta_{i} + \alpha$<br>    5. 检查训练集中是否还有误分类点，没有则算法结束，如果有则跳转到步骤 3 继续执行。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑回归</title>
      <link href="/2022/03/12/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/2022/03/12/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="1-从线性回归到逻辑回归"><a href="#1-从线性回归到逻辑回归" class="headerlink" title="1. 从线性回归到逻辑回归"></a>1. 从线性回归到逻辑回归</h2><p>​线性回归求的是输出特征向量 Y 和输入样本矩阵 X 之间的线性关系 $\theta$ ，满足 $Y = X\theta$ 。此时我们的 Y 是连续的，所以是回归模型，如果我要想要 Y 是离散值，则可以再对 Y 进行一次转换，变为 $g(Y)$，如果  $g(Y)$ 的值在某个区间内是类别 A，在另一个区间内是 B，这样就得到了一个分类模型。如果类别个数为 2，那么就是一个二分类模型。</p><h2 id="2-二元逻辑回归模型"><a href="#2-二元逻辑回归模型" class="headerlink" title="2. 二元逻辑回归模型"></a>2. 二元逻辑回归模型</h2><p>​逻辑回归模型就是在线性模型的基础之上加一个函数转换为离散值，这个函数在逻辑回归里面是 sigmod 函数：$g(z) = \frac{1}{1+e^{-z}}$ ，为什么是这个函数：</p><ul><li>当 $z$ 趋近于正无穷时，$g(z)$ 趋于 1 ，而当 z 趋于负无穷时，$g(z)$ 趋于0，这个性质很适合用来进行分类。</li><li>sigmod 函数还有一个很好的导数性质，$g^{‘}(z) = g(z)(1-g(z))$</li></ul><p>逻辑回归模型：</p><p>​$h_{\theta}(x) = \frac{1}{1+e^{-x\theta}}$ </p><p>$x$ 为样本输入，$h_{\theta}(x)$ 为模型输出，可以理解为某一类别的概率，而 $\theta$ 为模型参数，对于二元分类，如果 $h_{\theta}(x) &gt; 0.5$，即 $x\theta &gt; 0$，那么 y 预测为 1，如果 $h_{\theta}(x) &lt; 0.5$ ，即 $x\theta &lt; 0$，那么 y 预测为 0 。</p><p>逻辑回归的矩阵形式：</p><p>$h_{\theta}(X) = \frac{1}{1+e^{-X\theta}}$ , $h_{\theta}(X)$ 是模型输出，是 mx1 的维度，$X$ 是特征矩阵，是 mxn 的维度，$\theta$ 是分类模型的待求系数，是 nx1 的维度。</p><h2 id="3-二元逻辑回归的损失函数"><a href="#3-二元逻辑回归的损失函数" class="headerlink" title="3. 二元逻辑回归的损失函数"></a>3. 二元逻辑回归的损失函数</h2><p>​线性回归的输出是连续值，所以可以使用平方差来定义损失函数，但是逻辑回归的输出不是连续值，所以平方差损失函数不适合逻辑回归，不过可以使用最大似然法推导出损失函数。</p><p>​对于二元逻辑回归，假设输出 y 只有 0 和 1两类。</p><p>​$P(y=1|x,\theta) = h_{\theta}(x)$</p><p>​$P(y=0|x,\theta) = 1-h(\theta)$</p><p>写成一个函数就是：$P(y|x,\theta) = h_{\theta}(x)^{y}(1-h_{\theta}(x))^{1-y}$ ，y 只能取 0 和 1 。</p><p>通过似然函数最大化来求解参数 $\theta$ ，进行转换，将似然函数取对数并取反作为损失函数，然后最小化损失函数。</p><p>似然函数：$L(\theta) = \prod_{i=1}^{m}(h_{\theta}(x^{(i)}))^{y^{(i)}}(1-h_{\theta}(x^{(i)}))^{1-y^{(i)}}$</p><p>损失函数：$J(\theta) = -lnL(\theta) = -\sum_{i=1}^{m}(y^{(i)}log(h_{\theta}(x^{(i)}))+(1-y^{(i)})log(1-h_{\theta}(x^{(i)})))$   </p><p>损失函数的矩阵表式：$J(\theta) = -Y^Tlogh_{\theta}(X) - (E-Y)^Tlog(E-h_{\theta}(X))$，其中 E 为全 1 向量。</p><h2 id="4-二元逻辑回归损失函数的优化方法"><a href="#4-二元逻辑回归损失函数的优化方法" class="headerlink" title="4. 二元逻辑回归损失函数的优化方法"></a>4. 二元逻辑回归损失函数的优化方法</h2><p>​这里只介绍梯度下降法</p><p>$\frac{\partial}{\partial\theta}J(\theta) = X^T[\frac{1}{h_{\theta}(X)}\odot h_{\theta}(X)\odot(E-h_{\theta}(X))\odot(-Y)] + X^T[\frac{1}{E-h_{\theta}(X)}\odot h_{\theta}(X)\odot(E-h_{\theta}(X))\odot(E-Y)]$ </p><p>简化为：</p><p>$\frac{\partial}{\partial\theta}J(\theta) = X^T(h_{\theta}(X)-Y)$</p><p>迭代公式为：</p><p>$\theta = \theta - \alpha X^{T}(h_{\theta}(X) - Y)$ , $\alpha$ 为步长 。</p><h2 id="5-二元逻辑回归的正则化"><a href="#5-二元逻辑回归的正则化" class="headerlink" title="5. 二元逻辑回归的正则化"></a>5. 二元逻辑回归的正则化</h2><p>​逻辑回归也会有过拟合的问题，也需要考虑正则化，常见的有 $L1$ 正则化 和 $L2$ 正则化。</p><p>$L1$正则化</p><p>$J(\theta) = -Y^Tlogh_{\theta}(X) - (E-Y)^Tlog(E-h_{\theta}(X)) + \alpha\left | \theta \right |_{1}$ </p><p>$L2$ 正则化</p><p>$J(\theta) = -Y^Tlogh_{\theta}(X) - (E-Y)^Tlog(E-h_{\theta}(X)) + \frac{1}{2}\alpha\left | \theta \right |_{2}^{2}$ </p><h2 id="6-多元逻辑回归"><a href="#6-多元逻辑回归" class="headerlink" title="6. 多元逻辑回归"></a>6. 多元逻辑回归</h2><p>对于二元逻辑回归：</p><p>​$P(y=1|x,\theta) = h_{\theta}(x) = \frac{1}{1+e^{-x\theta}} = \frac{e^{x\theta}}{1+e^{x\theta}}$</p><p>​$P(y=0|x,\theta) = 1-h(\theta) = \frac{1}{1+e^{x\theta}}$ </p><p>​两则相除取对数</p><p>​$ln\frac{P(y=1|x,\theta) }{P(y=0|x,\theta)} = x\theta$<br>​</p><p>推广到多元，假设 y 的值可以取：$1,2,3\dots K$</p><p>$ln\frac{P(y=1|x,\theta) }{P(y=K|x,\theta)} = x\theta_{1}$</p><p>$ln\frac{P(y=2|x,\theta) }{P(y=K|x,\theta)} = x\theta_{2}$ </p><p>$\dots$</p><p>$ln\frac{P(y=K-1|x,\theta) }{P(y=K|x,\theta)} = x\theta_{K-1}$</p><p>$\sum_{i=1}^{K}P(y=i|x,\theta) = 1$</p><p>上面有 K 个方程，求解该方程得：</p><p>$P(y=k|x,\theta) = \frac{e^{x\theta_{k}}}{1+\sum_{t=1}^{K-1}e^{x\theta_{t}}}, k = 1,2,\dots K-1$</p><p>$P(y=k|x,\theta) = \frac{1}{1+\sum_{t=1}^{K-1}e^{x\theta_{t}}}$ </p><p>多元逻辑回归的损失函数和优化方法和二元逻辑回归类似 。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归</title>
      <link href="/2022/03/11/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2022/03/11/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><h3 id="1-线性回归的模型和损失函数"><a href="#1-线性回归的模型和损失函数" class="headerlink" title="1. 线性回归的模型和损失函数"></a>1. 线性回归的模型和损失函数</h3><p><strong>线性回归问题：</strong> 有 m 个样本，每个样本有 n 个特征和一个输出结果，$(x_{1}^{(i)},x_{2}^{(i)},\dots x_{n}^{(i)}), 其中 i = 1，2，3\dots m$ , 线性回归要解决的问题是对于一个新的 $(x_{1},x_{2},\dots,x_{n})$，它所对应的 $y$ 是多少，这里 $y$ 是连续的，所以这是一个回归问题，否则是一个分类问题。</p><p>如果这是一个线性模型，那么模型是这样的：</p><p>$h_{\theta}(x_{1},x_{2},\dots,x_{n}) = \theta_{0} + \theta_{1}x_{1}+\dots + \theta_{n}x_{n}$， 其中 $\theta_{i} (i=0,1,2,\dots n)$ 为模型参数，$x_{i} (i=1,2,3\dots n)$ 为每个样本的 n 个特征值，这个表示可以简化，我们增加一个特征 $x_{0} = 1$，这样就有 $h_{\theta}(x_{0},x_{1},\dots x_{n}) = \sum_{i=0}^{n}\theta_{i}x_{i}$  ，进一步用矩阵表示为 $h_{\theta}(X) = X\theta$ , 其中 $h_{\theta}(X)$ 是 mx1 的向量，$\theta$ 是 nx1 的向量，$X$ 是 mxn 维的矩阵，m 代表样本个数，n 代表样本的特征数 。</p><p>损失函数为：$J(\theta_{0},\theta_{1},\dots \theta_{n}) = \sum_{i=1}^{m}(h_{\theta}(x_{0}^{(i)},x_{1}^{(i)},\dots x_{n}^{(i)}) - y_{i})^2$ , 进一步用矩阵表示为 $J(\theta) = \frac{1}{2}(X\theta - Y)^T(X\theta - Y)$， 矩阵法表达更加简洁，后面就是用矩阵法来描述。</p><h3 id="2-线性回归算法的求解"><a href="#2-线性回归算法的求解" class="headerlink" title="2. 线性回归算法的求解"></a>2. 线性回归算法的求解</h3><p>​对于线性回归算法的损失函数 $J(\theta) = \frac{1}{2}(X\theta - Y)^T(X\theta - Y)$，一般要求该损失函数的最小化时的参数 $\theta$ 有两种方法：第一种是<strong>梯度下降法</strong>，第二种是<strong>最小二乘法</strong>，求解方法如下：</p><ol><li>梯度下降法公式：</li></ol><p>​$\theta = \theta - \alpha X^T(X\theta - Y)$，通过迭代 逐渐逼近最优的 $\theta$ </p><p>​2. 最小二乘法公式：</p><p>​$\theta = (X^TX)^{-1}X^TY$ </p><h3 id="3-线性回归之多项式回归"><a href="#3-线性回归之多项式回归" class="headerlink" title="3. 线性回归之多项式回归"></a>3. 线性回归之多项式回归</h3><p>​前面介绍的线性回归的拟合函数是线性函数，是一次项的，如果这里不是一次项，而是多次的，那么这个模型就变成了多项式回归，例如，假设有一个只有两个特征的二次多项式回归模型：</p><p>​$h_{\theta}(x_{1},h_{2}) = \theta_{0} + \theta_{1}x_{1}+\theta_{2}x_{2}+\theta_{3}x_{1}^{2}+\theta_{4}x_{2}^{2}+\theta_{5}x_{1}x_{2}$ </p><p>一开始只有 $x_{1},x_{2}$ 两个特征，现在构造特征 $x_{1}^{2},x_{2}^{2},x_{1}x_{2}$ ，令他们分别为特征 $x_{3},x_{4},x_{5}$ ，这样就有了一个线性模型：</p><p>​$h_{\theta}(x_{1},x_{2}) = \theta_{0} + \theta_{1}x_{1}+\theta_{2}x_{2}+\theta_{3}x_{3}+\theta_{4}x_{4}+\theta_{5}x_{5}$ </p><p>​通过改进特征，我们重新把不是线性回归的函数变回线性函数。</p><h3 id="4-线性回归之广义线性回归"><a href="#4-线性回归之广义线性回归" class="headerlink" title="4. 线性回归之广义线性回归"></a>4. 线性回归之广义线性回归</h3><p>​上一节是对特征进行变化推广，这一节对 y 进行推广，如果 我们的 Y 和 X 并不是成线性的关系，但是 $lnY$ 和 $X$ 是线性的关系，模型为：</p><p>​$ln(Y) = X\theta$</p><p>​这样我们修改 Y，将其变为 $lnY$ ，从而仍然可以使用线性回归的算法去处理这个问题。</p><p>​一般化： $g(Y) = X\theta $ 或者 $Y = g^{-1}(X\theta)$ </p><h3 id="5-线性回归的正则化"><a href="#5-线性回归的正则化" class="headerlink" title="5. 线性回归的正则化"></a>5. 线性回归的正则化</h3><p>​为了防止过拟合，在建立线性回归模型时我们经常需要加入正则化，一般正则化分为 $L1$ 正则化和 $L2$ 正则化。</p><p>​<strong>Lasso回归</strong> </p><p>​就是带 $L1$ 正则化项的 线性函数，和普通线性函数的区别就是在损失函数上增加了一个 $L1$ 正则化项。</p><p>​损失函数为：</p><p>​$J(\theta) = \frac{1}{2}(X\theta-Y)^T(X\theta-Y)+\alpha \left | \theta  \right |_{1}$ </p><p>​Lasso回归可以使得一些特征的系数变小，甚至还会使绝对值靠近 0 的参数变为 0，增强模型的泛化能力，因为参数过多容易过拟合，让某个参数变为 0 后，也就是减少了模型的参数。</p><p>​<strong>Ridge回归</strong></p><p>​就是带 $L2$ 正则化项的 线性函数，和普通线性函数的区别就是在损失函数上增加了一个 $L2$ 正则化项。</p><p>​损失函数为：</p><p>​$J(\theta) = \frac{1}{2}(X\theta-Y)^T(X\theta-Y)+\frac{1}{2}\alpha\left | \theta  \right |_{2}^{2} $ ，Ridge 和 Lasso的区别是 Lasso 可能会使某些特征消失，Ridge则是在保留所有特征的情况下，缩小回归系数，使模型相对而言比较稳定。</p><p>​使用最小二乘法求解：</p><p>​令 $J(\theta)$ 的导数为 0 ，得到下式：</p><p>​$X^T(X\theta - Y) + \alpha\theta = 0$</p><p>​整理即得 $\theta = (X^TX + \alpha E)^{-1}X^TY$ ，其中 $E$ 为单位矩阵。 </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小二乘法</title>
      <link href="/2022/03/10/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"/>
      <url>/2022/03/10/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h1><h3 id="1-最小二乘法介绍"><a href="#1-最小二乘法介绍" class="headerlink" title="1. 最小二乘法介绍"></a>1. 最小二乘法介绍</h3><p>​对于线性函数，其损失函数是平方差损失函数，表达式如下：</p><p>​$J(\theta) = \sum_{i=1}^{m}(y^{(i)}-h_{\theta}(x^{(i)}))^{2}$ </p><p>最小二乘法就是求解 参数 $\theta$ 使得 $J(\theta)$ 最小，不同于梯度下降法，梯度下降法是通过迭代一步步逼近最小值，而最小二乘法是通过求解方程组求得一个确切的值。</p><h3 id="2-最小二乘法的代数解法"><a href="#2-最小二乘法的代数解法" class="headerlink" title="2. 最小二乘法的代数解法"></a>2. 最小二乘法的代数解法</h3><ol><li><p>假设线性函数的拟合函数表示为 $h_{\theta}(x1,x2,\dots x_{n}) = \theta_{0} + \theta_{1}x_{1} + \dots + \theta_{n}x_{n}$ ，其中 $\theta_{i}$ 为模型参数，$x_{i}$  为每个样本的 n 个特征值，这个表示可以简化为 $h_{\theta}(x1,x2,\dots x_{n}) = \theta_{0} + \theta_{1}x_{1} + \dots + \theta_{n}x_{n} = \sum_{i=0}^{n}\theta_{i}x_{i}$ 。</p></li><li><p>损失函数表示为：$J(\theta_{0},\theta_{1},\dots,\theta_{n}) = \sum_{j=1}^{m}(h\theta(x_{0}^{(j)},x_{1}^{(j)},\dots,x_{n}^{(j)})-y^{(j)}) = \sum_{j=1}^{m}(\sum_{i=0}^{n}\theta_{i}x_{i}^{(j)}-y^{(j)})^{2}$ 。</p></li><li><p>利用损失函数对 各个参数求偏导，并令导数为 0 可得：$\sum_{j=1}^{m}(\sum_{i=0}^{n}\theta_{i}x_{i}^{(j)}-y^{(j)})x_{i}^{(j)} = 0$ 。</p></li><li><p>因为有 n+1 个参数，每个参数求一次偏导就有一个方程，故有 n+1 个方程，求解这个 n+1 元 一次方程，就可以得到所有的参数。</p></li></ol><h3 id="3-最小二乘法的矩阵解法"><a href="#3-最小二乘法的矩阵解法" class="headerlink" title="3. 最小二乘法的矩阵解法"></a>3. 最小二乘法的矩阵解法</h3><ol><li><p>假设函数 $h_{\theta}(x_{1},x_{2},\dots x_{n}) = \theta_{0} + \theta_{1}x_{1} + \dots + \theta_{n}x_{n}$ 的矩阵表达式为：$h_{\theta}(X) = X\theta$ ，其中假设函数 $h_{\theta}(X)$ 为 mx1 向量，$\theta$ 为 (n+1)x1的向量，是参数向量，$X$ 为 mx(n+1) 维的矩阵，m 代表样本的个数，n 代表样本的特征数，n+1 多 1 是因为线性函数有一个截距。</p></li><li><p>损失函数定义为 $\frac{1}{2}(X\theta - Y)^T(X\theta - Y)$ ，其中 $Y$ 是样本的输出向量，维度为 mx1，$\frac{1}{2}$ 是为了求导后计算方便。</p></li><li><p>对 $\theta$ 求偏导，公式如下：$\frac{\partial}{\partial\theta}J(\theta) = X^T(X\theta - Y) = 0 $ 。</p></li><li><p>通过整理，$X^TX\theta = X^TY$ ，两边同时左乘 $(X^TX)^{-1}$ 可得：$\theta = (X^TX)^{-1}X^TY$ ，这样就求出了 参数向量 $\theta$ ，不用像代数法一个一个求导，而且还要求一个方程组。</p></li></ol><h3 id="4-最小二乘法的局限性"><a href="#4-最小二乘法的局限性" class="headerlink" title="4. 最小二乘法的局限性"></a>4. 最小二乘法的局限性</h3><ol><li><p>最小二乘法需要计算 $X^TX$ 的逆，但是有可能它并不存在逆矩阵，这样就没有办法直接使用最小二乘法了，此时可以使用梯度下降法，当然 样本数据如果有很多冗余项的时候很容易出现 $X^TX$ 的行列式为 0 的情况，所以可以对数据进行预处理，去掉这个冗余特征，因为如果该特征冗余项很多，其实这个特征就不适合作为预测的依据。</p></li><li><p>当样本特征 n 非常大的时候，计算 $X^{T}X$ 的逆矩阵是一个非常耗时的工作，此时梯度下降法仍可以使用。</p></li><li><p>如果拟合的函数不是线性的，那么无法使用最小二乘法，此时梯度下降法仍然可以使用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降</title>
      <link href="/2022/03/09/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
      <url>/2022/03/09/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><h2 id="1-梯度"><a href="#1-梯度" class="headerlink" title="1. 梯度"></a>1. 梯度</h2><p><strong>数学定义：</strong> 在微积分里面，对一个多元函数的各个变量求偏导数，然后把各个变量的偏导数以向量的形式写出来，就是梯度。例如，对于函数 $f\left ( x,y \right )$ ,  它的梯度为$\left (  \frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\right)$，可以写为 $\nabla f\left ( x,y \right ) $ , 多个变量也是同理。</p><p><strong>梯度的几何意义：</strong> 对于多元函数来说，某个点的梯度就是该函数在该点变化最快的方向。例如，对于函数 $f\left ( x,y \right )$ ，在点$\left ( x_{0},y_{0} \right )$ , 沿着梯度方向 $\left (  \frac{\partial f}{\partial x_{0}},\frac{\partial f}{\partial y_{0}}\right)$就是函数 f 增长最快的方向，容易获得函数最大值，-$\left (  \frac{\partial f}{\partial x_{0}},\frac{\partial f}{\partial y_{0}}\right)$就是函数 f 减少最快的方向，容易获得函数最小值。</p><p><strong>梯度下降：</strong> 机器学习算法常用梯度下降法来最小化损失函数，通过一步步迭代，可以最小化损失函数以及求出模型的参数。</p><h2 id="2-梯度下降法算法"><a href="#2-梯度下降法算法" class="headerlink" title="2. 梯度下降法算法"></a>2. 梯度下降法算法</h2><p> <strong>2.1 直观解释算法：</strong></p><p>损失函数的图像就好比如一座大山，我们要以怎样的方式走到山底就好比如要以怎样的方式找到损失函数的最小值。梯度下降法的思想是，每走到一个地方，都要计算这个点的坡度（梯度），就是该位置最陡峭的方向，然后往这个方向走，走到下一个位置，再计算这个位置最陡峭的方向，一直这样走下去直到自己觉得走到了一个平坦的位置，也许这个平坦的位置并不是山底，而是一个局部的山峰底处。</p><p>从上面可以看出，梯度下降不一定能够找到全局最优解，但是如果函数是凸函数，梯度下降法就一定能求出全局最优解。</p><p><img src="/images/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg2MTcwMA==,size_16,color_FFFFFF,t_70.png" alt="梯度下降直观的解释"></p><p><strong>2.2 梯度下降法的相关概念：</strong></p><ol><li><p>步长：步长就是每一次沿负梯度方向走的长度，用上面上山的例子来说，就是沿最陡峭的方向一次走的路程，步长过大不易找到损失函数最小值，步长过小虽然可以找到很近似于损失函数最小值的那个值，但是寻找效率低。</p></li><li><p>特征：例如一个样本 $ \left ( x^{(0)},y^{(0)} \right )$，该样本特征为 $x^{(0)}$ ，输出为 $y^{(0)}$。</p></li><li><p>假设函数：在监督学习中，为了拟合输入的样本而使用的假设函数。</p></li><li><p>损失函数：是用来度量模型的拟合程度，损失函数极小化，说明拟合程度达到最好，所求模型的参数也即最优参数。</p></li></ol><p><strong>2.3 梯度下降算法的描述：</strong></p><p>​首先需要一个待优化模型的假设函数 $f(\theta)$ 和损失函数 $J(\theta)$ ，其中 $\theta = (\theta_{1},\theta_{2}\dots \theta_{n})$ 。</p><ol><li><p>确定当前位置损失函数的梯度，对于 $\theta_{i}$ 其梯度表达式为  $\frac{\partial}{\partial\theta_{i}}J(\theta_{0},\theta_{1}\dots\theta_{n})$ 。</p></li><li><p>用步长乘以损失函数的梯度，即得到当前位置的下降距离，即 $\alpha\frac{\partial}{\partial\theta_{i}}J(\theta_{0},\theta_{1}\dots\theta_{n})$ 。</p></li><li><p>确定所有 $\theta_{i}$ 梯度下降的距离都小于 $\varepsilon$ ，如果小于它，算法终止，当前的 $\theta$ 即为最终所求结果，否则进入步骤4 。</p></li><li><p>更新所有的 $\theta$，公式为 ：$\theta_{i} = \theta_{i} - \alpha\frac{\partial}{\partial\theta_{i}}J(\theta_{0},\theta_{1}\dots\theta_{n})$ ，更新完后继续执行步骤 1 。</p></li></ol><p><strong>2.4 梯度下降算法的调优：</strong></p><ol><li><p>算法的步长选择：步长的选择取决于数据样本，可以多取一些值，从大到小，用算法进行运行，看迭代的时候损失函数的变化，损失函数在减小说明取值有效，否则要增大步长。但是步长需要在一个适当的区间调整，步长过大可能会导致取不到最优解，步长过小，迭代速度会很慢，效率不高。</p></li><li><p>算法参数的初始值选择：参数初始值的不同，会取到不同的最小值，因为对于非凸函数，梯度下降法只能求到一个局部最优解，所以需要使用不同的初值运行算法，以免求到局部最优解。</p></li><li><p>归一化：由于数据中不同特征的取值范围可能相差很大，导致迭代过程缓慢，可以对特征数据归一化，也就是将特征进行如下处理$\frac{x-\bar{x}}{std(x)}$ ，其中 $\bar{x}$ 和 $std(x)$ 分别是该特征的平均值和标准差，这样该特征的期望就为 0 , 方差为 1，迭代速度就会得到加快。</p></li></ol><p>​<img src="/images/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/image-20220309192615536.png" alt="没有进行归一化损失函数的变化"><img src="/images/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/image-20220309192631031.png" alt="归一化后损失函数的变化"></p><p>上图中 $\theta_{1}$ 的范围远大于 $\theta_{2}$ 的范围，所以 $\theta_{2}$ 的变化对损失函数的影响会很大，$\theta_{1}$ 的变化对损失函数影响很小，就会导致迭代过程曲曲折折，迭代缓慢，右图是经过归一化后损失函数的变化，迭代速度明显会快。</p><h2 id="3-梯度下降法分类"><a href="#3-梯度下降法分类" class="headerlink" title="3. 梯度下降法分类"></a>3. 梯度下降法分类</h2><p><strong>批量梯度下降法（BGD）</strong></p><p>就是所有样本都用于计算损失函数。</p><p><strong>随机梯度下降法（SGD）</strong></p><p>计算损失函数只使用一个随机样本来进行计算。</p><p>两者的比较：随机梯度下降法只用一个样本进行计算，训练速度很快，而批量梯度下降法在数据集很大的时候，训练速度慢，对于准确度而言，随机梯度下降法只使用一个样本计算梯度，可能求得的不是最优解，对于收敛速度来说，随机梯度下降法一次迭代就是用一个样本，导致迭代的方向变化频繁，不能很快收敛到局部最优解。</p><p><strong>小批量梯度下降法（MBGD）</strong></p><p>小批量梯度下降法是以上两种方法的一种折衷，只取一定数量的样本来进行计算损失函数。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythonn高级用法</title>
      <link href="/2022/03/09/pythonn%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2022/03/09/pythonn%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="python高级用法"><a href="#python高级用法" class="headerlink" title="python高级用法"></a>python高级用法</h1><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>适用对象: list、tuple、str</p><ol><li><code>list[:]</code>返回原样list，:前面表示从哪个数组下标开始，:后表示从哪个数组下标的前一个结束。</li><li><code>list[-1:]</code>从倒数第一个到最后一个。</li><li><code>list[::5]</code> 间隔每隔5取一次。</li></ol><h3 id="all-和-any"><a href="#all-和-any" class="headerlink" title="all() 和 any()"></a>all() 和 any()</h3><ol><li><code>all()</code> 函数表示一个迭代对象里面都是True才返回True,否则返回False。</li><li><code>any()</code> 函数表示迭代对象里面只要有一个为True都返回True,否则返回False。</li></ol><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>适用对象：list、tuple、dict、set、str等可迭代对象，范围比较广。</p><ol><li><code>for x in list/tuple:</code> 迭代list和tuple对象</li><li><code>for key in dict:</code> 迭代dict对象<br>  <code>for value in dict.values():</code> 迭代dict的值<br>  <code>for k,v in dict.items():</code> 迭代dict的key和value</li><li><code>for ch in str:</code> 迭代字符串对象</li><li>如何判断一个对象是否是可迭代对象<br> 通过collections.abc模块中的Iterable类型来判断：<br>  <code>isinstance(object,Iterable)</code>: 判断object是否可迭代</li><li>对list的下标进行循环<br>  <code>for i,v in enumerate(list):</code> 迭代下标和下标对应的值<pre><code> list1=[1,2,3] list(enumerate(list1)) == [(0,1),(1,2),(2,3)]</code></pre></li></ol><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>写列表生成式时，把要生成的元素放在最前面，后面接for循环，最后可用if语句对循环值进行限制。</p><ol><li><code>[x+x for x in range(1,11)]</code> </li><li><code>[x+y for x in range(1,11) for y in range(1,5)]</code> 这里会生成 10 * 4 = 40 个元素，区别于：<pre><code>[x+y for x,y in zip(range(1,11),range(1,11))]  # 这里是将对应数组下标相同的元素相加list1=[1,2,3]list2=[4,5,6]zip(list1,list2)==[(1,4),(2,5),(3,6)]</code></pre></li><li><code>[x for x in range(1,11) if x%2==0]</code> 对循环值进行限制,这里if后面不能再跟elif和else了。</li><li><code>[key+'='+value for key,value in dict.items()]</code></li><li>[2 for i in range(3)] == [2,2,2]</li></ol><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>一边循环一边计算的机制，称为生成器：generator。</p><pre><code>L = [x * x for x in range(10)]L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]g = (x * x for x in range(10))g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</code></pre><ol><li>用next(g)来获得generator的下一个返回值，每次循环计算下一个值。</li><li>generator也是一个可迭代对象，可以用for循环。</li><li>对于复杂函数的生成器<pre><code>def fib(max): n, a, b = 0, 0, 1 while n &lt; max:     print(b)     a, b = b, a + b     n = n + 1 return 'done'</code></pre>这是一个普通的斐波那契函数。<br>现在需要将其改为生成器。<pre><code>def fib(max): n, a, b = 0, 0, 1 while n &lt; max:     yield b     a, b = b, a + b     n = n + 1 return 'done'&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x104feaaa0&gt;</code></pre>这时该函数就变成了一个生成器，用来生成斐波那契额数列。</li><li>普通函数和生成器的执行对比</li></ol><ul><li>普通函数是顺序执行的，遇到return语句返回或者执行完最后一条语句。</li><li>生成器是调用next()后才执行，执行到yield中断，并返回yield后的内容。下次再调用next()时，就从该yield处执行。</li></ul><ol start="5"><li>杨辉三角<pre><code>def triangles(): L=[1] while True:     yield L     S=L[:]     S.append(0)     L=[S[i-1]+S[i] for i in range(len(S))] </code></pre></li></ol><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>list、tuple、dict、set、str、generator都可以作为迭代器。</p><pre><code>isinstance([],Iterable)</code></pre><p>用来判断是否是迭代对象。</p><hr><h3 id="异常、错误与调试"><a href="#异常、错误与调试" class="headerlink" title="异常、错误与调试"></a>异常、错误与调试</h3><ol><li><p>try-except-finally模式</p><pre><code>try: 语句except Ex1: 语句finally: 语句</code></pre><p>finally不管有没有出错都要执行的语句。</p></li><li><p>try-except-else 模式<br>当try捕获到异常时会跳转到except处，出错位置后的代码将不再执行，当try没有捕获到错误时，就会跳转到else进行处理。</p><pre><code>try: 语句except Ex1: 语句else: 语句</code></pre></li><li><p>raise 手动抛出异常</p><pre><code>raise ValueError("This is a Exception")</code></pre></li><li><p><strong>pycharm调试</strong></p></li></ol><ul><li>step over 跳过子函数运行，（就是整个函数作为一行运行）。</li><li>step into 遇到子函数，进入子函数。</li><li>step out 当单步执行在子函数内，用step out 可以执行完剩余的子函数，并跳出来。</li><li>resume program 跳到下一个断点处。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythonn基础</title>
      <link href="/2022/03/08/pythonn%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/08/pythonn%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p>python采用缩进的方式来区分代码块，采用 # 来标记注释，python程序还是大小写敏感的。</p><h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><p>计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p><ol><li><p>整型：十六进制数前面需要加上<strong>Ox</strong></p><ul><li>进制转换：<ul><li>二进制转为十进制：<code>int('10',2) == 2</code></li><li>八进制转为十进制：<code>int('04',8) == 4</code></li><li>十六进制转十进制：<code>int('0x4',16) == 4</code></li><li>转为二进制：<code>bin(int)</code></li><li>转为八进制：<code>oct(int)</code></li><li>转十六进制：<code>hex(int)</code></li></ul></li></ul></li><li><p>浮点数：可以用科学计数法表示，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5,整数运算永远都是正确的，例如，print(5/2)得到2.5，而浮点数运算需要考虑四舍五入的误差。</p></li><li><p>字符串：</p><ul><li>转义字符，转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\。</li><li>为了简化，Python还允许用 r’ ‘ 表示’’内部的字符串默认不转义，原样输出。</li><li>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’的格式表示多行内容。</li><li>字符串合并：<code>'-'.join(['c','l'])=='c-l'</code> ,用-将列表连接起来形成字符串。</li><li>大小写： 大写upper()、小写lower()。</li><li>去除字符串左右的空白字符，<code>" 123 ".strip()</code></li><li>字符串排序：strlist.sort(), 按字符串长度排序：<br> <code>strlist.sort(key=lambda x:len(list(x)))</code></li><li>字符串也可以切割，和列表一样</li><li>大小写 s.upper() 和 s.lower() </li><li>判断是否以XX开头或结尾 s.startswith(‘a’)、s.endswith(‘a’)</li><li>分割字符串 s.split(sep=) 默认sep为空格</li><li>is系列：<ul><li>isalnum()：所有字符都是数字或者字母</li><li>isalpha()：所有字符都是字母</li><li>isdigit()：所有字符都是数字</li><li>islower()：所有字符都是小写</li><li>isupper()：所有字符都是大写</li><li>istitle()：首字母为大写，其余都为小写</li><li>isspace()：所有字符都是空白符</li></ul></li><li>计算字符串中某字符出现的次数：s.count(‘a’)</li><li>替换字符串中的指定字符或字符串：s.replace(‘abcd’,’efgh’)</li><li>format格式化输出：<pre><code>s = '我叫{}, 今年{}， 性别{}'.format('小五', 25, '女')s1 = '我叫{0}, 今年{1}， 性别{2}，我依然叫{0}'.format('小五', 25, '女')s2 = '我叫{name}, 今年{age}， 性别{sex}，我依然叫{name}'.format(age=25, sex='女',name='小五'）</code></pre></li><li>首字母变成大写：s.capitalize()</li><li>将字符串居中：s.center(50) 在50的长度里面字符串s居中显示，也可以填充：s.center(50,’*’)</li><li>“-“.join(list)：将list连接成字符串</li><li>字符串倒置：str[::-1]</li></ul></li><li><p>布尔类型：</p><ul><li>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写）。</li><li>布尔类型可以用and、or和not运算。</li></ul></li><li><p>空值：空值是Python里一个特殊的值，用<strong>None</strong>表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>可以为变量赋不同类型的值。这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。</p><ol><li>10/3 是精确的，浮点数，这里的精确不是说得到的值是精确的，而是不会像c语言那样只取得整数部分，其实浮点数都是不准确的，你不能用两个浮点数去做相等判断。</li><li>9/3 得到的也是浮点数3.0。</li><li>10//3=3 只取整数部分的除法。</li><li>10%3=1 求余运算。</li></ol><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><ol><li>链式赋值语句: i=j=1</li><li>复合赋值语句: k+=20 </li><li>序列的拆包式赋值: a,b,c = 1,2,3</li><li>两个变量调换: a,b = b,a</li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>和C语言Java语言不一样，python使用 <strong>#</strong> 来进行注释，而且没有多行注释。</li><li>在jupyter notebook中，代码行与注释行的相互切换使用 Ctrl+/ </li><li>docstring，文档信息，在iPython中可以用？来显示文档信息，这个文档信息就是目标程序中用三个双引号括起来的多行说明性文字。</li></ol><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ol><li><p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p></li><li><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p></li><li><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p></li><li><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p></li></ol><ul><li><blockquote><p>ord(‘A’)<br>65</p></blockquote></li><li><blockquote><p>ord(‘中’)<br>20013</p></blockquote></li><li><blockquote><p>chr(66)<br>‘B’</p></blockquote></li><li><blockquote><p>chr(25991)<br>‘文’</p></blockquote></li><li><blockquote><p>‘\u4e2d\u6587’<br>‘中文’</p></blockquote></li></ul><ol start="5"><li>%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</li></ol><ul><li><blockquote><p>‘Hello, %s’ % ‘world’<br>‘Hello, world’</p></blockquote></li><li><blockquote><p>‘Hi, %s, you have $%d.’ % (‘Michael’, 1000000)<br>‘Hi, Michael, you have $1000000.’</p></blockquote></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol><li>除法：y/x 运算结果为浮点数, // 代表取除数结果的整数部分</li><li>幂次：x**y x的y次幂</li><li>is / not is：判断是否指向的是同一个索引</li><li>in / not in： 判断x是否在给定的容器中，例如List、Set、Tuple等</li><li>逻辑运算符：and / or / not</li><li>位运算： bin(x) 可以将x变为二进制数据，然后可以通过 &amp;、|、^、~、&gt;&gt;、&lt;&lt; 进行位运算，分别表示 与、或、异或、取反、右移、左移运算，<strong>取反运算比较复杂，从结果来说：取反结果为：原数+1再变相反数。</strong><pre><code>x=2y=3bin(x&amp;y)</code></pre></li><li>pow（2,10），round(2.991)都是内置函数</li><li>math模块的函数和常量：<ul><li>math.sin(x)</li><li>math.pi</li><li>math.sqrt(x) 求平方根，x为负数则报错</li></ul></li></ol><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h3><ol><li><p>list是一种有序的集合，可以随时添加和删除其中的元素，用中括号括住。</p></li><li><p>用len()可以获得其大小</p></li><li><p>用索引访问list中的每一个元素</p><blockquote><p>classmates[0]<br> ‘Michael’</p></blockquote></li><li><p>获取最后一个元素-1，倒数第二个元素-2。</p><blockquote><p>classmates[-1]<br> ‘Tracy’</p></blockquote></li><li><p>list追加元素</p><blockquote><p>classmates.append(‘Adam’)</p></blockquote></li><li><p>list插入元素</p><blockquote><p>classmates.insert(1, ‘Jack’) 插入索引为1的位置。</p></blockquote></li><li><p>list删除末尾元素</p><blockquote><p>classmates.pop()</p></blockquote></li><li><p>删除指定元素</p><blockquote><p>classmates.pop(i) 删除索引为i的元素。<br> 或者classmates.remove(‘Adam’)</p></blockquote></li><li><p>修改索引位置元素</p><blockquote><p>classmates[1] = ‘Sarah’</p></blockquote></li><li><p>清空列表</p><blockquote><p>list.clear()</p></blockquote></li><li><p>取元素对应的索引</p><blockquote><p>list.index(‘Adam’)</p></blockquote></li><li><p>对数组排序</p><blockquote><p>list.sort()<br> 或者 sorted(list)<br><code>sort()</code>对原数组进行排序<br><code>sorted()</code>会返回一个新迭代对象<br>以上两个函数都可以通过key来进行自定义排序</p></blockquote></li><li><p>数组元素反转</p><ul><li>list.reverse()</li><li>reversed(list) 内置函数</li><li>list[::-1]</li></ul></li><li><p>list中的加法和乘法</p><ul><li>[1,2]+[3,4]=[1,2,3,4]</li><li>[1] x 3 = [1,1,1]</li></ul></li><li><p>list进行强制转换<br>list(“xulei”)</p><blockquote><p>[‘x’,’u’,’l’,’e’,’i’]</p></blockquote></li><li><p>list1.extend(list2)方法类似于 list1+list2<br>list1.append(list2) 就是将list2作为一个元素追加到list1中去</p></li><li><p>list之间赋值<br>lis[:3] = list[2::-1]   在原数组上倒置前三个元素</p></li></ol><p>【注】list中的元素可以是任何类型，包括list，可以组成二维数组，三维数组…</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple和list的区别：tuple定义之后就不能修改了，没有append()和insert()函数，用大括号括起。</p><ol><li>定义一个空的tuple<blockquote><p>t=()</p></blockquote></li><li>定义只有一个元素的tuple<blockquote><p>t=(1,)<br> 不能 t=(1)</p></blockquote></li><li><code>tuple.index(obj)</code>：从元组中找出某个值第一个匹配项的索引值</li><li><code>tuple.count(obj)</code>： 统计某个元素在元组中出现的次数</li></ol><h3 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h3><pre><code>if 表达式 :    ...elif 表达式 :    ...else :    ...</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Python的循环有两种</p><ol><li><p>一种是for…in循环，依次把list或tuple中的每个元素迭代出来。</p><pre><code>for 元素 in list/tuple : ...</code></pre><p><code>range(i)</code>：可以生成0~i-1的整数序列。<br><code>list()</code>:可以转换为list。</p></li><li><p>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。</p><pre><code>while 表达式： ...</code></pre></li><li><p>break语句<br>跳出循环</p></li><li><p>continue语句<br>跳出本次循环</p></li></ol><h3 id="dict-字典"><a href="#dict-字典" class="headerlink" title="dict(字典)"></a>dict(字典)</h3><p>类似于其它语言中的Map</p><blockquote><p>d = {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}<br>d[‘Michael’]<br>95</p></blockquote><p>把数据放入dict</p><blockquote><p>d[‘Adam’] = 67<br>d[‘Adam’]</p></blockquote><p><strong>dict是无序的</strong></p><ol><li>多次将一个相同的key值插入字典，后面的会覆盖前面的。</li><li>查看某个key值是否在字典中<br>key in dict<br>会返回布尔类型</li><li>dict的get方法<br> <code>d.get(key，default)</code><br>会返回该key值对应的value，若key值不存在，返回default。</li><li>删除一个键值对</li><li>dict是不可变的<br>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。<br>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key<br> <code>d.pop(key)</code></li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>和字典类似，不过这里只有key没有value，且key不能重复，也没有顺序。set的创建需要一个list作为输入。对于list中重复的数据，set会过滤只保留一个。</p><ol><li>add(key) :可以往set中加元素，可以重复但不会有效。</li><li>remove(key) :可以删除set中的key。</li><li>set可以看成是数学上的无序无重复的集合，故可以做交集并集操作。<br>交集：s1 &amp; s2<br>并集：s1 | s2<br>子集：{ 1，5 } &lt; { 1,3,5 }<br>差集：{ 1，3，5 }-{ 1，3 }=={ 5 }</li><li>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。</li><li>确定性：<code>2 in myset</code> 返回true。</li><li>无序性：不能通过下标访问集合的某个元素。</li><li>互异性：{1，2，3} 和 {1，2，3，1，2}是两个相同的集合。</li><li>支持集合运算 </li><li>属于可变对象</li></ol><p>list、tuple、dict和set的区别：<br><strong>一句话来概括四种数据类型的区别是：tuple是一个不可改变的list，set是一个没有Value的dict，list和set的数据是可变的，tuple和dict的数据是不可变的！</strong></p><p>list和set的数据可变的，tuple和dict的数据是不可变的。list是最自由的，可以使用索引、切片，可以进行计算和修改；tuple是不自由的，数据不能更改，但是和list一样具有序列，可以用索引和切片；dict是半自由的，自由体现在键值对的无序，可以通过key去索引value的值，不自由体现在数据操作只能通过key来实现，键值对是不可变类型；set是半自由的，自由体现在它通过list传值给它，数据类型是可变的，还可以改变list中的值，数据集是无序的，不重复的，可以进行计算，不自由体现在无法使用索引和切片准确定位。</p><ul><li>不可变对象：当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。</li><li>可变对象：变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是<strong>原地改变</strong>。</li></ul><h3 id="模块函数"><a href="#模块函数" class="headerlink" title="模块函数"></a>模块函数</h3><p>需要先导入后才能使用<br>模块就是一个py文件，多个模块 + <strong>init</strong>.py文件这就是一个包</p><ol><li>导入模块的三种方式：<ul><li>import 模块名</li><li>import 模块名 as 别名</li><li>from 模块名 import 函数名</li><li>from 包名.文件名 import 类名/函数</li></ul></li><li>模块就是一个.py文件，如果多个人创建了同名的.py文件，又引入了包的概念，包下一定要有__init__.py才能叫做包。</li></ol><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>在python解释器中的函数，可以直接通过函数名来调用函数。</p><ol><li>查看内置函数的一个帮助文档<pre><code>help(len)len?</code></pre></li><li>常见的内置函数<ul><li>help(): 帮助函数</li><li>type(): 查看类型</li><li>id(): 查看id</li><li>len(): 计算长度</li><li>isinstance(): 判断是否属于特定的数据类型</li></ul></li><li>类型函数<ul><li>int()</li><li>bool()</li><li>float()</li><li>str()</li><li>list()</li><li>set()</li><li>tuple()</li></ul></li><li>其他<ul><li>type() 查看数据类型</li><li>isinstance() 判断数据类型</li><li>dir() 查看某个对象所支持的方法/属性清单</li><li>callable() 判断是否可以调用</li><li>help() 查看帮助</li><li>bin() 十进制转为二进制</li><li>hex() 十进制转为十六进制</li></ul></li><li>包<ul><li>查看已安装包的列表   pip list </li><li>更新某已安装的包pip install –upgradeo 包名</li><li>移除某已安装包 pip uninstall包名</li><li>下载/安装指定的包  pip install 包名</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python介绍</title>
      <link href="/2022/03/08/python%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/03/08/python%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Python介绍"><a href="#Python介绍" class="headerlink" title="Python介绍"></a>Python介绍</h1><h3 id="python简介"><a href="#python简介" class="headerlink" title="python简介"></a>python简介</h3><p>Python是一个解释型语言<br>优点：简单、提供很多的基础代码库<br>缺点：运行速度慢、代码不能加密，源代码暴露</p><h3 id="python解释器"><a href="#python解释器" class="headerlink" title="python解释器"></a>python解释器</h3><ol><li>Cpython：用的最多</li><li>Ipython: 交互式解释器</li><li>PyPy: 执行速度快</li></ol><h3 id="命令行模式和python交互模式"><a href="#命令行模式和python交互模式" class="headerlink" title="命令行模式和python交互模式"></a>命令行模式和python交互模式</h3><ol><li>cmd进入的就是命令行模式，输入python可以看到对应的python版本并进入到python交互模式，在交互模式又可以输入exit()退出到命令行模式。</li><li>也可以在命令行下 python + 文件名（.py）运行python文件，这里需要时绝对路径。</li><li>在python交互模式下可以直接输入100+200回车，会得到300，但是要在文件中运行需要print(100+200)才能看到结果。</li><li>在window中py文件不能像exe文件那样直接运行，不过在mac和linux中可以，需要在py文件的第一行加上一个特殊注释**#!/usr/bin/env python3**，然后给该文件赋予执行权限chmod a+x hello.py，最后命令行 ./hello.py 就可以运行。</li></ol><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><ol><li><strong>输出</strong><ul><li>print()，字符串用 ”或 ‘，多个字符串可以用逗号或者+号连接，逗号连接中间会加个空格，+号连接会直接连接起来。</li><li>逗号也可以用来连接多个不同类型的输出，例如print(“100+200=”,100+200)。</li><li>按格式输出：print(“%s : %s”,(str1,str2))</li></ul></li><li><strong>输入</strong><ul><li>input(),用户可以输入一个字符串，并赋给name，例如，<strong>name=input()</strong>,键盘输入的内容会到name中去。</li><li>你也可以加一个输入提示，例如：<strong>name=input(“请输入你的姓名：”)</strong></li><li>input键盘输入的都是字符串类型，例如x1=input(“请输入第一个数：”) ， x2=input(“请输入第二个数：”) ，print(x1+x2) 输出结果为23 而不是5 。</li></ul></li></ol><p>【注】input返回结果是str。</p>]]></content>
      
      
      <categories>
          
          <category> Python学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
