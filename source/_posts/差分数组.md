---
title: 差分数组
tags: 算法
categories: 算法
mathjax: true
abbrlink: 54851
date: 2022-05-15 19:18:42
---

# 差分数组

### 适用问题

​	频繁地对原始数组的某个区间的元素进行增减。

### 算法框架

```java
// 构造差分数组
int[] diff = new int[nums.length];
diff[0] = nums[0];
for(int i=1;i<nums.length;i++){
    diff[i] = nums[i] - nums[i-1];
}
// 通过差分数组修改原始数组
public void increment(int i,int j,int val){
    diff[i] += val;
    if(j+1<nums.length){
        diff[j+1] -= val;
    }
}
// 返回修改后的原始数组
public int[] result(){
    int[] res = new int[nums.length];
    res[0] = diff[0];
    for(int i=1;i<nums.length;i++){
        res[i] = diff[i] + res[i-1];
    }
    return res;
}
```

### 题目

1. 区间加法（370）

   假设有一个长度为 n 的数组，初始情况下所有的数字均为0，你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组[startindex, endindex, inc]，目的是修改原始数组的 [startindex，endindex] 的值。

   ```java
   int[] getModifiedArray(int length,int[][] updatesets){
       int[] res = new int[length];
       int[] diff = new int[length];
       for(int[] update:updates){
           int left = update[0];
           int right = update[1];
           int val = update[2];
           diff[left] += val;
           if(right+1<length){
               diff[right+1]-=val;
           }
       }
       res[0] = diff[0];
       for(int i=1;i<length;i++){
           res[i] = res[i-1] + diff[i]
       }
       return res;
   }
   ```

2.  航班预定统计（1109）

​	https://leetcode.cn/problems/corporate-flight-bookings/

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] diff = new int[n];
        int[] res = new int[n];
        for(int[] book:bookings){
            int start = book[0]-1;
            int end = book[1]-1;
            int val = book[2];
            diff[start] += val;
            if(end+1 < n){
                diff[end+1]-=val;
            }
        } 
        res[0] = diff[0];
        for(int i=1;i<n;i++){
            res[i] = res[i-1]+diff[i];
        }
        return res;
    }
}
```

​	3. 拼车（1094）

​	https://leetcode.cn/problems/car-pooling/

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int[] diff = new int[1000];
        int[] res = new int[1000];
        for(int[] trip:trips){
            int start = trip[1];
            int end = trip[2] - 1;   // 因为trip[2]人已经下车了
            int val = trip[0];
            diff[start] += val;
            if(end+1<1000){
                diff[end+1] -= val;
            }
        }
        res[0] = diff[0];
        int m = res[0];
        for(int i=1;i<1000;i++){
            res[i] = res[i-1]+diff[i];
            if(res[i]>m){
                m = res[i];
            }
        }
        return m>capacity?false:true;
    }
}
```

















